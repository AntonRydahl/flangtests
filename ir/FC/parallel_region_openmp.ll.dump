*** IR Dump After Annotation2MetadataPass on [module] ***
; ModuleID = 'FIRModule'
source_filename = "FIRModule"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.ident_t = type { i32, i32, i32, i32, ptr }

@_QMomp_libEComp_allocator_handle_kind = external constant i32
@_QMomp_libEComp_alloctrait_key_kind = external constant i32
@_QMomp_libEComp_alloctrait_val_kind = external constant i32
@_QMomp_libEComp_allow_completion_event = external constant i32
@_QMomp_libEComp_atk_access = external constant i32
@_QMomp_libEComp_atk_alignment = external constant i32
@_QMomp_libEComp_atk_fallback = external constant i32
@_QMomp_libEComp_atk_fb_data = external constant i32
@_QMomp_libEComp_atk_partition = external constant i32
@_QMomp_libEComp_atk_pinned = external constant i32
@_QMomp_libEComp_atk_pool_size = external constant i32
@_QMomp_libEComp_atk_sync_hint = external constant i32
@_QMomp_libEComp_atv_abort_fb = external constant i32
@_QMomp_libEComp_atv_all = external constant i32
@_QMomp_libEComp_atv_allocator_fb = external constant i32
@_QMomp_libEComp_atv_blocked = external constant i32
@_QMomp_libEComp_atv_cgroup = external constant i32
@_QMomp_libEComp_atv_contended = external constant i32
@_QMomp_libEComp_atv_default = external constant i32
@_QMomp_libEComp_atv_default_mem_fb = external constant i32
@_QMomp_libEComp_atv_environment = external constant i32
@_QMomp_libEComp_atv_false = external constant i32
@_QMomp_libEComp_atv_interleaved = external constant i32
@_QMomp_libEComp_atv_nearest = external constant i32
@_QMomp_libEComp_atv_null_fb = external constant i32
@_QMomp_libEComp_atv_private = external constant i32
@_QMomp_libEComp_atv_pteam = external constant i32
@_QMomp_libEComp_atv_sequential = external constant i32
@_QMomp_libEComp_atv_thread = external constant i32
@_QMomp_libEComp_atv_true = external constant i32
@_QMomp_libEComp_atv_uncontended = external constant i32
@_QMomp_libEComp_cgroup_mem_alloc = external constant i32
@_QMomp_libEComp_const_mem_alloc = external constant i32
@_QMomp_libEComp_const_mem_space = external constant i32
@_QMomp_libEComp_default_mem_alloc = external constant i32
@_QMomp_libEComp_default_mem_space = external constant i32
@_QMomp_libEComp_depend_kind = external constant i32
@_QMomp_libEComp_event_handle_kind = external constant i32
@_QMomp_libEComp_high_bw_mem_alloc = external constant i32
@_QMomp_libEComp_high_bw_mem_space = external constant i32
@_QMomp_libEComp_integer_kind = external constant i32
@_QMomp_libEComp_large_cap_mem_alloc = external constant i32
@_QMomp_libEComp_large_cap_mem_space = external constant i32
@_QMomp_libEComp_lock_hint_contended = external constant i32
@_QMomp_libEComp_lock_hint_kind = external constant i32
@_QMomp_libEComp_lock_hint_none = external constant i32
@_QMomp_libEComp_lock_hint_nonspeculative = external constant i32
@_QMomp_libEComp_lock_hint_speculative = external constant i32
@_QMomp_libEComp_lock_hint_uncontended = external constant i32
@_QMomp_libEComp_lock_kind = external constant i32
@_QMomp_libEComp_logical_kind = external constant i32
@_QMomp_libEComp_low_lat_mem_alloc = external constant i32
@_QMomp_libEComp_low_lat_mem_space = external constant i32
@_QMomp_libEComp_memspace_handle_kind = external constant i32
@_QMomp_libEComp_nest_lock_kind = external constant i32
@_QMomp_libEComp_null_allocator = external constant i32
@_QMomp_libEComp_pause_hard = external constant i32
@_QMomp_libEComp_pause_resource_kind = external constant i32
@_QMomp_libEComp_pause_soft = external constant i32
@_QMomp_libEComp_proc_bind_close = external constant i32
@_QMomp_libEComp_proc_bind_false = external constant i32
@_QMomp_libEComp_proc_bind_kind = external constant i32
@_QMomp_libEComp_proc_bind_master = external constant i32
@_QMomp_libEComp_proc_bind_spread = external constant i32
@_QMomp_libEComp_proc_bind_true = external constant i32
@_QMomp_libEComp_pteam_mem_alloc = external constant i32
@_QMomp_libEComp_sched_auto = external constant i32
@_QMomp_libEComp_sched_dynamic = external constant i32
@_QMomp_libEComp_sched_guided = external constant i32
@_QMomp_libEComp_sched_kind = external constant i32
@_QMomp_libEComp_sched_static = external constant i32
@_QMomp_libEComp_sync_hint_contended = external constant i32
@_QMomp_libEComp_sync_hint_kind = external constant i32
@_QMomp_libEComp_sync_hint_none = external constant i32
@_QMomp_libEComp_sync_hint_nonspeculative = external constant i32
@_QMomp_libEComp_sync_hint_speculative = external constant i32
@_QMomp_libEComp_sync_hint_uncontended = external constant i32
@_QMomp_libEComp_task_fulfill_event = external constant i32
@_QMomp_libEComp_thread_mem_alloc = external constant i32
@_QMomp_libECopenmp_version = external constant i32
@_QQcl.28612C69372C612C6531332E36653229 = internal constant [16 x i8] c"(a,i7,a,e13.6e2)"
@_QQcl.21557d42704c5c1f18a68415065290ee = internal constant [50 x i8] c"/g/g92/rydahl1/flangtests/src/parallel_region.f90\00"
@_QQcl.54686520726573756C74206F6620286172722831292B61727228 = internal constant [26 x i8] c"The result of (arr(1)+arr("
@_QQcl.2920697320 = internal constant [5 x i8] c") is "
@_QQEnvironmentDefaults = constant ptr null
@0 = private unnamed_addr constant [23 x i8] c";unknown;unknown;0;0;;\00", align 1
@1 = private unnamed_addr constant %struct.ident_t { i32 0, i32 2, i32 0, i32 22, ptr @0 }, align 8

declare ptr @malloc(i64)

declare void @free(ptr)

define void @_QQmain() {
  %1 = alloca i32, i64 1, align 4
  %2 = alloca double, i64 1, align 8
  %3 = alloca double, i64 1, align 8
  store i32 1048576, ptr %1, align 4, !tbaa !4
  call void @_QFPomp_subroutine(ptr %1, ptr %2)
  %4 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %5 = call i1 @_FortranAioOutputAscii(ptr %4, ptr @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %6 = load i32, ptr %1, align 4, !tbaa !4
  %7 = call i1 @_FortranAioOutputInteger32(ptr %4, i32 %6)
  %8 = call i1 @_FortranAioOutputAscii(ptr %4, ptr @_QQcl.2920697320, i64 5)
  %9 = load double, ptr %2, align 8, !tbaa !4
  %10 = call i1 @_FortranAioOutputReal64(ptr %4, double %9)
  %11 = call i32 @_FortranAioEndIoStatement(ptr %4)
  ret void
}

define void @_QFPomp_subroutine(ptr %0, ptr %1) {
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %5 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %6 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %7 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %8 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %9 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, i64 1, align 8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } { ptr null, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), i32 20180515, i8 1, i8 28, i8 2, i8 0, [1 x [3 x i64]] [[3 x i64] [i64 1, i64 0, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64)]] }, ptr %8, align 8, !tbaa !8
  %10 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %8, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %10, ptr %9, align 8, !tbaa !8
  %11 = alloca i32, i64 1, align 4
  %12 = alloca i32, i64 1, align 4
  %13 = alloca i32, i64 1, align 4
  %14 = alloca i32, i64 1, align 4
  %15 = alloca i32, i64 1, align 4
  %16 = alloca double, i64 1, align 8
  %17 = alloca i32, i64 1, align 4
  %18 = load i32, ptr %0, align 4, !tbaa !4
  %19 = sext i32 %18 to i64
  %20 = icmp sgt i64 %19, 0
  %21 = select i1 %20, i64 %19, i64 0
  %22 = mul i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), %21
  %23 = call ptr @malloc(i64 %22)
  %24 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } { ptr undef, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), i32 20180515, i8 1, i8 28, i8 2, i8 0, [1 x [3 x i64]] [[3 x i64] [i64 1, i64 undef, i64 undef]] }, i64 %21, 7, 0, 1
  %25 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %24, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), 7, 0, 2
  %26 = mul i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), %21
  %27 = mul i64 1, %21
  %28 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %25, ptr %23, 0
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %28, ptr %7, align 8, !tbaa !8
  %29 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %7, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %29, ptr %9, align 8, !tbaa !8
  br label %entry

entry:                                            ; preds = %2
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr @1)
  br label %omp_parallel

omp_parallel:                                     ; preds = %entry
  %gep_ = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 0
  store ptr %0, ptr %gep_, align 8
  %gep_8 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 1
  store ptr %9, ptr %gep_8, align 8
  %gep_9 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 2
  store ptr %6, ptr %gep_9, align 8
  %gep_10 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 3
  store ptr %5, ptr %gep_10, align 8
  %gep_11 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 4
  store ptr %16, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @1, i32 1, ptr @_QFPomp_subroutine..omp_par, ptr %structArg)
  br label %omp.par.outlined.exit

omp.par.outlined.exit:                            ; preds = %omp_parallel
  br label %omp.par.exit.split

omp.par.exit.split:                               ; preds = %omp.par.outlined.exit
  %30 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %9, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %30, ptr %4, align 8, !tbaa !8
  %31 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i64 0, i32 0
  %32 = load i64, ptr %31, align 8, !tbaa !8
  %33 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i64 0, i32 1
  %34 = load i64, ptr %33, align 8, !tbaa !8
  %35 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i64 0, i32 2
  %36 = load i64, ptr %35, align 8, !tbaa !8
  %37 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 0
  %38 = load ptr, ptr %37, align 8, !tbaa !8
  %39 = sub i64 1, %32
  %40 = getelementptr double, ptr %38, i64 %39
  %41 = load double, ptr %40, align 8, !tbaa !4
  %42 = load i32, ptr %0, align 4, !tbaa !4
  %43 = sext i32 %42 to i64
  %44 = sub i64 %43, %32
  %45 = getelementptr double, ptr %38, i64 %44
  %46 = load double, ptr %45, align 8, !tbaa !4
  %47 = fadd contract double %41, %46
  store double %47, ptr %1, align 8, !tbaa !4
  %48 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %9, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %48, ptr %3, align 8, !tbaa !8
  %49 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i32 0, i32 0
  %50 = load ptr, ptr %49, align 8, !tbaa !8
  call void @free(ptr %50)
  %51 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %8, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %51, ptr %9, align 8, !tbaa !8
  ret void
}

; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #0 {
omp.par.entry:
  %gep_ = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 0
  %loadgep_ = load ptr, ptr %gep_, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %tid.addr.local = alloca i32, align 4
  %1 = load i32, ptr %tid.addr, align 4
  store i32 %1, ptr %tid.addr.local, align 4
  %tid = load i32, ptr %tid.addr.local, align 4
  br label %omp.par.region

omp.par.region:                                   ; preds = %omp.par.entry
  br label %omp.par.region1

omp.par.region1:                                  ; preds = %omp.par.region
  %2 = alloca i32, i64 1, align 4
  %3 = alloca i32, i64 1, align 4
  %4 = alloca i32, i64 1, align 4
  %5 = alloca i32, i64 1, align 4
  %6 = alloca i32, i64 1, align 4
  %7 = alloca i32, i64 1, align 4
  %8 = call i32 @omp_get_thread_num()
  store i32 %8, ptr %3, align 4, !tbaa !4
  %9 = call i32 @omp_get_num_threads()
  store i32 %9, ptr %4, align 4, !tbaa !4
  %10 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %11 = load i32, ptr %4, align 4, !tbaa !4
  %12 = sdiv i32 %10, %11
  store i32 %12, ptr %7, align 4, !tbaa !4
  %13 = load i32, ptr %3, align 4, !tbaa !4
  %14 = load i32, ptr %7, align 4, !tbaa !4
  %15 = mul i32 %13, %14
  %16 = add i32 %15, 1
  store i32 %16, ptr %5, align 4, !tbaa !4
  %17 = load i32, ptr %3, align 4, !tbaa !4
  %18 = load i32, ptr %4, align 4, !tbaa !4
  %19 = sub i32 %18, 1
  %20 = icmp eq i32 %17, %19
  br i1 %20, label %omp.par.region2, label %omp.par.region3

omp.par.region3:                                  ; preds = %omp.par.region1
  %21 = load i32, ptr %5, align 4, !tbaa !4
  %22 = load i32, ptr %7, align 4, !tbaa !4
  %23 = add i32 %21, %22
  store i32 %23, ptr %6, align 4, !tbaa !4
  br label %omp.par.region4

omp.par.region4:                                  ; preds = %omp.par.region2, %omp.par.region3
  %24 = load i32, ptr %5, align 4, !tbaa !4
  %25 = sext i32 %24 to i64
  %26 = load i32, ptr %6, align 4, !tbaa !4
  %27 = sext i32 %26 to i64
  %28 = trunc i64 %25 to i32
  %29 = sub i64 %27, %25
  %30 = add i64 %29, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.region4
  %31 = phi i32 [ %66, %omp.par.region6 ], [ %28, %omp.par.region4 ]
  %32 = phi i64 [ %67, %omp.par.region6 ], [ %30, %omp.par.region4 ]
  %33 = icmp sgt i64 %32, 0
  br i1 %33, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  store i32 %31, ptr %2, align 4, !tbaa !4
  br label %omp.region.cont

omp.region.cont:                                  ; preds = %omp.par.region7
  br label %omp.par.pre_finalize

omp.par.pre_finalize:                             ; preds = %omp.region.cont
  br label %omp.par.outlined.exit.exitStub

omp.par.region6:                                  ; preds = %omp.par.region5
  store i32 %31, ptr %2, align 4, !tbaa !4
  %34 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %35 = sitofp i32 %34 to float
  %36 = fdiv contract float 1.000000e+00, %35
  %37 = fpext float %36 to double
  %38 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %38, ptr %loadgep_4, align 8, !tbaa !8
  %39 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 0
  %40 = load i64, ptr %39, align 8, !tbaa !8
  %41 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 1
  %42 = load i64, ptr %41, align 8, !tbaa !8
  %43 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 2
  %44 = load i64, ptr %43, align 8, !tbaa !8
  %45 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 0
  %46 = load ptr, ptr %45, align 8, !tbaa !8
  %47 = load i32, ptr %2, align 4, !tbaa !4
  %48 = sext i32 %47 to i64
  %49 = sub i64 %48, %40
  %50 = getelementptr double, ptr %46, i64 %49
  store double %37, ptr %50, align 8, !tbaa !4
  %51 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %51, ptr %loadgep_6, align 8, !tbaa !8
  %52 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 0
  %53 = load i64, ptr %52, align 8, !tbaa !8
  %54 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 1
  %55 = load i64, ptr %54, align 8, !tbaa !8
  %56 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 2
  %57 = load i64, ptr %56, align 8, !tbaa !8
  %58 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 0
  %59 = load ptr, ptr %58, align 8, !tbaa !8
  %60 = load i32, ptr %2, align 4, !tbaa !4
  %61 = sext i32 %60 to i64
  %62 = sub i64 %61, %53
  %63 = getelementptr double, ptr %59, i64 %62
  %64 = load double, ptr %63, align 8, !tbaa !4
  store double %64, ptr %loadgep_8, align 8, !tbaa !4
  %65 = load i32, ptr %2, align 4, !tbaa !4
  %66 = add i32 %65, 1
  %67 = sub i64 %32, 1
  br label %omp.par.region5

omp.par.region2:                                  ; preds = %omp.par.region1
  %68 = load i32, ptr %loadgep_, align 4, !tbaa !4
  store i32 %68, ptr %6, align 4, !tbaa !4
  br label %omp.par.region4

omp.par.outlined.exit.exitStub:                   ; preds = %omp.par.pre_finalize
  ret void
}

declare ptr @_FortranAioBeginExternalFormattedOutput(ptr, i64, ptr, i32, ptr, i32)

declare zeroext i1 @_FortranAioOutputAscii(ptr, ptr, i64)

declare zeroext i1 @_FortranAioOutputInteger32(ptr, i32)

declare zeroext i1 @_FortranAioOutputReal64(ptr, double)

declare i32 @_FortranAioEndIoStatement(ptr)

declare i32 @omp_get_thread_num()

declare i32 @omp_get_num_threads()

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare ptr @llvm.stacksave() #1

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.stackrestore(ptr) #1

; Function Attrs: nounwind
declare i32 @__kmpc_global_thread_num(ptr) #2

; Function Attrs: nounwind
declare !callback !10 void @__kmpc_fork_call(ptr, i32, ptr, ...) #2

attributes #0 = { norecurse nounwind }
attributes #1 = { nocallback nofree nosync nounwind willreturn }
attributes #2 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i32 7, !"openmp", i32 11}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{!5, !5, i64 0}
!5 = !{!"any data access", !6, i64 0}
!6 = !{!"any access", !7, i64 0}
!7 = !{!"Flang Type TBAA Root"}
!8 = !{!9, !9, i64 0}
!9 = !{!"descriptor member", !6, i64 0}
!10 = !{!11}
!11 = !{i64 2, i64 -1, i64 -1, i1 true}
*** IR Dump After ForceFunctionAttrsPass on [module] ***
; ModuleID = 'FIRModule'
source_filename = "FIRModule"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.ident_t = type { i32, i32, i32, i32, ptr }

@_QMomp_libEComp_allocator_handle_kind = external constant i32
@_QMomp_libEComp_alloctrait_key_kind = external constant i32
@_QMomp_libEComp_alloctrait_val_kind = external constant i32
@_QMomp_libEComp_allow_completion_event = external constant i32
@_QMomp_libEComp_atk_access = external constant i32
@_QMomp_libEComp_atk_alignment = external constant i32
@_QMomp_libEComp_atk_fallback = external constant i32
@_QMomp_libEComp_atk_fb_data = external constant i32
@_QMomp_libEComp_atk_partition = external constant i32
@_QMomp_libEComp_atk_pinned = external constant i32
@_QMomp_libEComp_atk_pool_size = external constant i32
@_QMomp_libEComp_atk_sync_hint = external constant i32
@_QMomp_libEComp_atv_abort_fb = external constant i32
@_QMomp_libEComp_atv_all = external constant i32
@_QMomp_libEComp_atv_allocator_fb = external constant i32
@_QMomp_libEComp_atv_blocked = external constant i32
@_QMomp_libEComp_atv_cgroup = external constant i32
@_QMomp_libEComp_atv_contended = external constant i32
@_QMomp_libEComp_atv_default = external constant i32
@_QMomp_libEComp_atv_default_mem_fb = external constant i32
@_QMomp_libEComp_atv_environment = external constant i32
@_QMomp_libEComp_atv_false = external constant i32
@_QMomp_libEComp_atv_interleaved = external constant i32
@_QMomp_libEComp_atv_nearest = external constant i32
@_QMomp_libEComp_atv_null_fb = external constant i32
@_QMomp_libEComp_atv_private = external constant i32
@_QMomp_libEComp_atv_pteam = external constant i32
@_QMomp_libEComp_atv_sequential = external constant i32
@_QMomp_libEComp_atv_thread = external constant i32
@_QMomp_libEComp_atv_true = external constant i32
@_QMomp_libEComp_atv_uncontended = external constant i32
@_QMomp_libEComp_cgroup_mem_alloc = external constant i32
@_QMomp_libEComp_const_mem_alloc = external constant i32
@_QMomp_libEComp_const_mem_space = external constant i32
@_QMomp_libEComp_default_mem_alloc = external constant i32
@_QMomp_libEComp_default_mem_space = external constant i32
@_QMomp_libEComp_depend_kind = external constant i32
@_QMomp_libEComp_event_handle_kind = external constant i32
@_QMomp_libEComp_high_bw_mem_alloc = external constant i32
@_QMomp_libEComp_high_bw_mem_space = external constant i32
@_QMomp_libEComp_integer_kind = external constant i32
@_QMomp_libEComp_large_cap_mem_alloc = external constant i32
@_QMomp_libEComp_large_cap_mem_space = external constant i32
@_QMomp_libEComp_lock_hint_contended = external constant i32
@_QMomp_libEComp_lock_hint_kind = external constant i32
@_QMomp_libEComp_lock_hint_none = external constant i32
@_QMomp_libEComp_lock_hint_nonspeculative = external constant i32
@_QMomp_libEComp_lock_hint_speculative = external constant i32
@_QMomp_libEComp_lock_hint_uncontended = external constant i32
@_QMomp_libEComp_lock_kind = external constant i32
@_QMomp_libEComp_logical_kind = external constant i32
@_QMomp_libEComp_low_lat_mem_alloc = external constant i32
@_QMomp_libEComp_low_lat_mem_space = external constant i32
@_QMomp_libEComp_memspace_handle_kind = external constant i32
@_QMomp_libEComp_nest_lock_kind = external constant i32
@_QMomp_libEComp_null_allocator = external constant i32
@_QMomp_libEComp_pause_hard = external constant i32
@_QMomp_libEComp_pause_resource_kind = external constant i32
@_QMomp_libEComp_pause_soft = external constant i32
@_QMomp_libEComp_proc_bind_close = external constant i32
@_QMomp_libEComp_proc_bind_false = external constant i32
@_QMomp_libEComp_proc_bind_kind = external constant i32
@_QMomp_libEComp_proc_bind_master = external constant i32
@_QMomp_libEComp_proc_bind_spread = external constant i32
@_QMomp_libEComp_proc_bind_true = external constant i32
@_QMomp_libEComp_pteam_mem_alloc = external constant i32
@_QMomp_libEComp_sched_auto = external constant i32
@_QMomp_libEComp_sched_dynamic = external constant i32
@_QMomp_libEComp_sched_guided = external constant i32
@_QMomp_libEComp_sched_kind = external constant i32
@_QMomp_libEComp_sched_static = external constant i32
@_QMomp_libEComp_sync_hint_contended = external constant i32
@_QMomp_libEComp_sync_hint_kind = external constant i32
@_QMomp_libEComp_sync_hint_none = external constant i32
@_QMomp_libEComp_sync_hint_nonspeculative = external constant i32
@_QMomp_libEComp_sync_hint_speculative = external constant i32
@_QMomp_libEComp_sync_hint_uncontended = external constant i32
@_QMomp_libEComp_task_fulfill_event = external constant i32
@_QMomp_libEComp_thread_mem_alloc = external constant i32
@_QMomp_libECopenmp_version = external constant i32
@_QQcl.28612C69372C612C6531332E36653229 = internal constant [16 x i8] c"(a,i7,a,e13.6e2)"
@_QQcl.21557d42704c5c1f18a68415065290ee = internal constant [50 x i8] c"/g/g92/rydahl1/flangtests/src/parallel_region.f90\00"
@_QQcl.54686520726573756C74206F6620286172722831292B61727228 = internal constant [26 x i8] c"The result of (arr(1)+arr("
@_QQcl.2920697320 = internal constant [5 x i8] c") is "
@_QQEnvironmentDefaults = constant ptr null
@0 = private unnamed_addr constant [23 x i8] c";unknown;unknown;0;0;;\00", align 1
@1 = private unnamed_addr constant %struct.ident_t { i32 0, i32 2, i32 0, i32 22, ptr @0 }, align 8

declare ptr @malloc(i64)

declare void @free(ptr)

define void @_QQmain() {
  %1 = alloca i32, i64 1, align 4
  %2 = alloca double, i64 1, align 8
  %3 = alloca double, i64 1, align 8
  store i32 1048576, ptr %1, align 4, !tbaa !4
  call void @_QFPomp_subroutine(ptr %1, ptr %2)
  %4 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %5 = call i1 @_FortranAioOutputAscii(ptr %4, ptr @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %6 = load i32, ptr %1, align 4, !tbaa !4
  %7 = call i1 @_FortranAioOutputInteger32(ptr %4, i32 %6)
  %8 = call i1 @_FortranAioOutputAscii(ptr %4, ptr @_QQcl.2920697320, i64 5)
  %9 = load double, ptr %2, align 8, !tbaa !4
  %10 = call i1 @_FortranAioOutputReal64(ptr %4, double %9)
  %11 = call i32 @_FortranAioEndIoStatement(ptr %4)
  ret void
}

define void @_QFPomp_subroutine(ptr %0, ptr %1) {
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %5 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %6 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %7 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %8 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %9 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, i64 1, align 8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } { ptr null, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), i32 20180515, i8 1, i8 28, i8 2, i8 0, [1 x [3 x i64]] [[3 x i64] [i64 1, i64 0, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64)]] }, ptr %8, align 8, !tbaa !8
  %10 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %8, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %10, ptr %9, align 8, !tbaa !8
  %11 = alloca i32, i64 1, align 4
  %12 = alloca i32, i64 1, align 4
  %13 = alloca i32, i64 1, align 4
  %14 = alloca i32, i64 1, align 4
  %15 = alloca i32, i64 1, align 4
  %16 = alloca double, i64 1, align 8
  %17 = alloca i32, i64 1, align 4
  %18 = load i32, ptr %0, align 4, !tbaa !4
  %19 = sext i32 %18 to i64
  %20 = icmp sgt i64 %19, 0
  %21 = select i1 %20, i64 %19, i64 0
  %22 = mul i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), %21
  %23 = call ptr @malloc(i64 %22)
  %24 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } { ptr undef, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), i32 20180515, i8 1, i8 28, i8 2, i8 0, [1 x [3 x i64]] [[3 x i64] [i64 1, i64 undef, i64 undef]] }, i64 %21, 7, 0, 1
  %25 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %24, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), 7, 0, 2
  %26 = mul i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), %21
  %27 = mul i64 1, %21
  %28 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %25, ptr %23, 0
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %28, ptr %7, align 8, !tbaa !8
  %29 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %7, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %29, ptr %9, align 8, !tbaa !8
  br label %entry

entry:                                            ; preds = %2
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr @1)
  br label %omp_parallel

omp_parallel:                                     ; preds = %entry
  %gep_ = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 0
  store ptr %0, ptr %gep_, align 8
  %gep_8 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 1
  store ptr %9, ptr %gep_8, align 8
  %gep_9 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 2
  store ptr %6, ptr %gep_9, align 8
  %gep_10 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 3
  store ptr %5, ptr %gep_10, align 8
  %gep_11 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 4
  store ptr %16, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @1, i32 1, ptr @_QFPomp_subroutine..omp_par, ptr %structArg)
  br label %omp.par.outlined.exit

omp.par.outlined.exit:                            ; preds = %omp_parallel
  br label %omp.par.exit.split

omp.par.exit.split:                               ; preds = %omp.par.outlined.exit
  %30 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %9, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %30, ptr %4, align 8, !tbaa !8
  %31 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i64 0, i32 0
  %32 = load i64, ptr %31, align 8, !tbaa !8
  %33 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i64 0, i32 1
  %34 = load i64, ptr %33, align 8, !tbaa !8
  %35 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i64 0, i32 2
  %36 = load i64, ptr %35, align 8, !tbaa !8
  %37 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 0
  %38 = load ptr, ptr %37, align 8, !tbaa !8
  %39 = sub i64 1, %32
  %40 = getelementptr double, ptr %38, i64 %39
  %41 = load double, ptr %40, align 8, !tbaa !4
  %42 = load i32, ptr %0, align 4, !tbaa !4
  %43 = sext i32 %42 to i64
  %44 = sub i64 %43, %32
  %45 = getelementptr double, ptr %38, i64 %44
  %46 = load double, ptr %45, align 8, !tbaa !4
  %47 = fadd contract double %41, %46
  store double %47, ptr %1, align 8, !tbaa !4
  %48 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %9, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %48, ptr %3, align 8, !tbaa !8
  %49 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i32 0, i32 0
  %50 = load ptr, ptr %49, align 8, !tbaa !8
  call void @free(ptr %50)
  %51 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %8, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %51, ptr %9, align 8, !tbaa !8
  ret void
}

; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #0 {
omp.par.entry:
  %gep_ = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 0
  %loadgep_ = load ptr, ptr %gep_, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %tid.addr.local = alloca i32, align 4
  %1 = load i32, ptr %tid.addr, align 4
  store i32 %1, ptr %tid.addr.local, align 4
  %tid = load i32, ptr %tid.addr.local, align 4
  br label %omp.par.region

omp.par.region:                                   ; preds = %omp.par.entry
  br label %omp.par.region1

omp.par.region1:                                  ; preds = %omp.par.region
  %2 = alloca i32, i64 1, align 4
  %3 = alloca i32, i64 1, align 4
  %4 = alloca i32, i64 1, align 4
  %5 = alloca i32, i64 1, align 4
  %6 = alloca i32, i64 1, align 4
  %7 = alloca i32, i64 1, align 4
  %8 = call i32 @omp_get_thread_num()
  store i32 %8, ptr %3, align 4, !tbaa !4
  %9 = call i32 @omp_get_num_threads()
  store i32 %9, ptr %4, align 4, !tbaa !4
  %10 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %11 = load i32, ptr %4, align 4, !tbaa !4
  %12 = sdiv i32 %10, %11
  store i32 %12, ptr %7, align 4, !tbaa !4
  %13 = load i32, ptr %3, align 4, !tbaa !4
  %14 = load i32, ptr %7, align 4, !tbaa !4
  %15 = mul i32 %13, %14
  %16 = add i32 %15, 1
  store i32 %16, ptr %5, align 4, !tbaa !4
  %17 = load i32, ptr %3, align 4, !tbaa !4
  %18 = load i32, ptr %4, align 4, !tbaa !4
  %19 = sub i32 %18, 1
  %20 = icmp eq i32 %17, %19
  br i1 %20, label %omp.par.region2, label %omp.par.region3

omp.par.region3:                                  ; preds = %omp.par.region1
  %21 = load i32, ptr %5, align 4, !tbaa !4
  %22 = load i32, ptr %7, align 4, !tbaa !4
  %23 = add i32 %21, %22
  store i32 %23, ptr %6, align 4, !tbaa !4
  br label %omp.par.region4

omp.par.region4:                                  ; preds = %omp.par.region2, %omp.par.region3
  %24 = load i32, ptr %5, align 4, !tbaa !4
  %25 = sext i32 %24 to i64
  %26 = load i32, ptr %6, align 4, !tbaa !4
  %27 = sext i32 %26 to i64
  %28 = trunc i64 %25 to i32
  %29 = sub i64 %27, %25
  %30 = add i64 %29, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.region4
  %31 = phi i32 [ %66, %omp.par.region6 ], [ %28, %omp.par.region4 ]
  %32 = phi i64 [ %67, %omp.par.region6 ], [ %30, %omp.par.region4 ]
  %33 = icmp sgt i64 %32, 0
  br i1 %33, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  store i32 %31, ptr %2, align 4, !tbaa !4
  br label %omp.region.cont

omp.region.cont:                                  ; preds = %omp.par.region7
  br label %omp.par.pre_finalize

omp.par.pre_finalize:                             ; preds = %omp.region.cont
  br label %omp.par.outlined.exit.exitStub

omp.par.region6:                                  ; preds = %omp.par.region5
  store i32 %31, ptr %2, align 4, !tbaa !4
  %34 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %35 = sitofp i32 %34 to float
  %36 = fdiv contract float 1.000000e+00, %35
  %37 = fpext float %36 to double
  %38 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %38, ptr %loadgep_4, align 8, !tbaa !8
  %39 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 0
  %40 = load i64, ptr %39, align 8, !tbaa !8
  %41 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 1
  %42 = load i64, ptr %41, align 8, !tbaa !8
  %43 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 2
  %44 = load i64, ptr %43, align 8, !tbaa !8
  %45 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 0
  %46 = load ptr, ptr %45, align 8, !tbaa !8
  %47 = load i32, ptr %2, align 4, !tbaa !4
  %48 = sext i32 %47 to i64
  %49 = sub i64 %48, %40
  %50 = getelementptr double, ptr %46, i64 %49
  store double %37, ptr %50, align 8, !tbaa !4
  %51 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %51, ptr %loadgep_6, align 8, !tbaa !8
  %52 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 0
  %53 = load i64, ptr %52, align 8, !tbaa !8
  %54 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 1
  %55 = load i64, ptr %54, align 8, !tbaa !8
  %56 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 2
  %57 = load i64, ptr %56, align 8, !tbaa !8
  %58 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 0
  %59 = load ptr, ptr %58, align 8, !tbaa !8
  %60 = load i32, ptr %2, align 4, !tbaa !4
  %61 = sext i32 %60 to i64
  %62 = sub i64 %61, %53
  %63 = getelementptr double, ptr %59, i64 %62
  %64 = load double, ptr %63, align 8, !tbaa !4
  store double %64, ptr %loadgep_8, align 8, !tbaa !4
  %65 = load i32, ptr %2, align 4, !tbaa !4
  %66 = add i32 %65, 1
  %67 = sub i64 %32, 1
  br label %omp.par.region5

omp.par.region2:                                  ; preds = %omp.par.region1
  %68 = load i32, ptr %loadgep_, align 4, !tbaa !4
  store i32 %68, ptr %6, align 4, !tbaa !4
  br label %omp.par.region4

omp.par.outlined.exit.exitStub:                   ; preds = %omp.par.pre_finalize
  ret void
}

declare ptr @_FortranAioBeginExternalFormattedOutput(ptr, i64, ptr, i32, ptr, i32)

declare zeroext i1 @_FortranAioOutputAscii(ptr, ptr, i64)

declare zeroext i1 @_FortranAioOutputInteger32(ptr, i32)

declare zeroext i1 @_FortranAioOutputReal64(ptr, double)

declare i32 @_FortranAioEndIoStatement(ptr)

declare i32 @omp_get_thread_num()

declare i32 @omp_get_num_threads()

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare ptr @llvm.stacksave() #1

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.stackrestore(ptr) #1

; Function Attrs: nounwind
declare i32 @__kmpc_global_thread_num(ptr) #2

; Function Attrs: nounwind
declare !callback !10 void @__kmpc_fork_call(ptr, i32, ptr, ...) #2

attributes #0 = { norecurse nounwind }
attributes #1 = { nocallback nofree nosync nounwind willreturn }
attributes #2 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i32 7, !"openmp", i32 11}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{!5, !5, i64 0}
!5 = !{!"any data access", !6, i64 0}
!6 = !{!"any access", !7, i64 0}
!7 = !{!"Flang Type TBAA Root"}
!8 = !{!9, !9, i64 0}
!9 = !{!"descriptor member", !6, i64 0}
!10 = !{!11}
!11 = !{i64 2, i64 -1, i64 -1, i1 true}
*** IR Dump After InferFunctionAttrsPass on [module] ***
; ModuleID = 'FIRModule'
source_filename = "FIRModule"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.ident_t = type { i32, i32, i32, i32, ptr }

@_QMomp_libEComp_allocator_handle_kind = external constant i32
@_QMomp_libEComp_alloctrait_key_kind = external constant i32
@_QMomp_libEComp_alloctrait_val_kind = external constant i32
@_QMomp_libEComp_allow_completion_event = external constant i32
@_QMomp_libEComp_atk_access = external constant i32
@_QMomp_libEComp_atk_alignment = external constant i32
@_QMomp_libEComp_atk_fallback = external constant i32
@_QMomp_libEComp_atk_fb_data = external constant i32
@_QMomp_libEComp_atk_partition = external constant i32
@_QMomp_libEComp_atk_pinned = external constant i32
@_QMomp_libEComp_atk_pool_size = external constant i32
@_QMomp_libEComp_atk_sync_hint = external constant i32
@_QMomp_libEComp_atv_abort_fb = external constant i32
@_QMomp_libEComp_atv_all = external constant i32
@_QMomp_libEComp_atv_allocator_fb = external constant i32
@_QMomp_libEComp_atv_blocked = external constant i32
@_QMomp_libEComp_atv_cgroup = external constant i32
@_QMomp_libEComp_atv_contended = external constant i32
@_QMomp_libEComp_atv_default = external constant i32
@_QMomp_libEComp_atv_default_mem_fb = external constant i32
@_QMomp_libEComp_atv_environment = external constant i32
@_QMomp_libEComp_atv_false = external constant i32
@_QMomp_libEComp_atv_interleaved = external constant i32
@_QMomp_libEComp_atv_nearest = external constant i32
@_QMomp_libEComp_atv_null_fb = external constant i32
@_QMomp_libEComp_atv_private = external constant i32
@_QMomp_libEComp_atv_pteam = external constant i32
@_QMomp_libEComp_atv_sequential = external constant i32
@_QMomp_libEComp_atv_thread = external constant i32
@_QMomp_libEComp_atv_true = external constant i32
@_QMomp_libEComp_atv_uncontended = external constant i32
@_QMomp_libEComp_cgroup_mem_alloc = external constant i32
@_QMomp_libEComp_const_mem_alloc = external constant i32
@_QMomp_libEComp_const_mem_space = external constant i32
@_QMomp_libEComp_default_mem_alloc = external constant i32
@_QMomp_libEComp_default_mem_space = external constant i32
@_QMomp_libEComp_depend_kind = external constant i32
@_QMomp_libEComp_event_handle_kind = external constant i32
@_QMomp_libEComp_high_bw_mem_alloc = external constant i32
@_QMomp_libEComp_high_bw_mem_space = external constant i32
@_QMomp_libEComp_integer_kind = external constant i32
@_QMomp_libEComp_large_cap_mem_alloc = external constant i32
@_QMomp_libEComp_large_cap_mem_space = external constant i32
@_QMomp_libEComp_lock_hint_contended = external constant i32
@_QMomp_libEComp_lock_hint_kind = external constant i32
@_QMomp_libEComp_lock_hint_none = external constant i32
@_QMomp_libEComp_lock_hint_nonspeculative = external constant i32
@_QMomp_libEComp_lock_hint_speculative = external constant i32
@_QMomp_libEComp_lock_hint_uncontended = external constant i32
@_QMomp_libEComp_lock_kind = external constant i32
@_QMomp_libEComp_logical_kind = external constant i32
@_QMomp_libEComp_low_lat_mem_alloc = external constant i32
@_QMomp_libEComp_low_lat_mem_space = external constant i32
@_QMomp_libEComp_memspace_handle_kind = external constant i32
@_QMomp_libEComp_nest_lock_kind = external constant i32
@_QMomp_libEComp_null_allocator = external constant i32
@_QMomp_libEComp_pause_hard = external constant i32
@_QMomp_libEComp_pause_resource_kind = external constant i32
@_QMomp_libEComp_pause_soft = external constant i32
@_QMomp_libEComp_proc_bind_close = external constant i32
@_QMomp_libEComp_proc_bind_false = external constant i32
@_QMomp_libEComp_proc_bind_kind = external constant i32
@_QMomp_libEComp_proc_bind_master = external constant i32
@_QMomp_libEComp_proc_bind_spread = external constant i32
@_QMomp_libEComp_proc_bind_true = external constant i32
@_QMomp_libEComp_pteam_mem_alloc = external constant i32
@_QMomp_libEComp_sched_auto = external constant i32
@_QMomp_libEComp_sched_dynamic = external constant i32
@_QMomp_libEComp_sched_guided = external constant i32
@_QMomp_libEComp_sched_kind = external constant i32
@_QMomp_libEComp_sched_static = external constant i32
@_QMomp_libEComp_sync_hint_contended = external constant i32
@_QMomp_libEComp_sync_hint_kind = external constant i32
@_QMomp_libEComp_sync_hint_none = external constant i32
@_QMomp_libEComp_sync_hint_nonspeculative = external constant i32
@_QMomp_libEComp_sync_hint_speculative = external constant i32
@_QMomp_libEComp_sync_hint_uncontended = external constant i32
@_QMomp_libEComp_task_fulfill_event = external constant i32
@_QMomp_libEComp_thread_mem_alloc = external constant i32
@_QMomp_libECopenmp_version = external constant i32
@_QQcl.28612C69372C612C6531332E36653229 = internal constant [16 x i8] c"(a,i7,a,e13.6e2)"
@_QQcl.21557d42704c5c1f18a68415065290ee = internal constant [50 x i8] c"/g/g92/rydahl1/flangtests/src/parallel_region.f90\00"
@_QQcl.54686520726573756C74206F6620286172722831292B61727228 = internal constant [26 x i8] c"The result of (arr(1)+arr("
@_QQcl.2920697320 = internal constant [5 x i8] c") is "
@_QQEnvironmentDefaults = constant ptr null
@0 = private unnamed_addr constant [23 x i8] c";unknown;unknown;0;0;;\00", align 1
@1 = private unnamed_addr constant %struct.ident_t { i32 0, i32 2, i32 0, i32 22, ptr @0 }, align 8

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite)
declare noalias noundef ptr @malloc(i64 noundef) #0

; Function Attrs: mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite)
declare void @free(ptr allocptr nocapture noundef) #1

define void @_QQmain() {
  %1 = alloca i32, i64 1, align 4
  %2 = alloca double, i64 1, align 8
  %3 = alloca double, i64 1, align 8
  store i32 1048576, ptr %1, align 4, !tbaa !4
  call void @_QFPomp_subroutine(ptr %1, ptr %2)
  %4 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %5 = call i1 @_FortranAioOutputAscii(ptr %4, ptr @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %6 = load i32, ptr %1, align 4, !tbaa !4
  %7 = call i1 @_FortranAioOutputInteger32(ptr %4, i32 %6)
  %8 = call i1 @_FortranAioOutputAscii(ptr %4, ptr @_QQcl.2920697320, i64 5)
  %9 = load double, ptr %2, align 8, !tbaa !4
  %10 = call i1 @_FortranAioOutputReal64(ptr %4, double %9)
  %11 = call i32 @_FortranAioEndIoStatement(ptr %4)
  ret void
}

define void @_QFPomp_subroutine(ptr %0, ptr %1) {
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %5 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %6 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %7 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %8 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %9 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, i64 1, align 8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } { ptr null, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), i32 20180515, i8 1, i8 28, i8 2, i8 0, [1 x [3 x i64]] [[3 x i64] [i64 1, i64 0, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64)]] }, ptr %8, align 8, !tbaa !8
  %10 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %8, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %10, ptr %9, align 8, !tbaa !8
  %11 = alloca i32, i64 1, align 4
  %12 = alloca i32, i64 1, align 4
  %13 = alloca i32, i64 1, align 4
  %14 = alloca i32, i64 1, align 4
  %15 = alloca i32, i64 1, align 4
  %16 = alloca double, i64 1, align 8
  %17 = alloca i32, i64 1, align 4
  %18 = load i32, ptr %0, align 4, !tbaa !4
  %19 = sext i32 %18 to i64
  %20 = icmp sgt i64 %19, 0
  %21 = select i1 %20, i64 %19, i64 0
  %22 = mul i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), %21
  %23 = call ptr @malloc(i64 %22)
  %24 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } { ptr undef, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), i32 20180515, i8 1, i8 28, i8 2, i8 0, [1 x [3 x i64]] [[3 x i64] [i64 1, i64 undef, i64 undef]] }, i64 %21, 7, 0, 1
  %25 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %24, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), 7, 0, 2
  %26 = mul i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), %21
  %27 = mul i64 1, %21
  %28 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %25, ptr %23, 0
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %28, ptr %7, align 8, !tbaa !8
  %29 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %7, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %29, ptr %9, align 8, !tbaa !8
  br label %entry

entry:                                            ; preds = %2
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr @1)
  br label %omp_parallel

omp_parallel:                                     ; preds = %entry
  %gep_ = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 0
  store ptr %0, ptr %gep_, align 8
  %gep_8 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 1
  store ptr %9, ptr %gep_8, align 8
  %gep_9 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 2
  store ptr %6, ptr %gep_9, align 8
  %gep_10 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 3
  store ptr %5, ptr %gep_10, align 8
  %gep_11 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 4
  store ptr %16, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @1, i32 1, ptr @_QFPomp_subroutine..omp_par, ptr %structArg)
  br label %omp.par.outlined.exit

omp.par.outlined.exit:                            ; preds = %omp_parallel
  br label %omp.par.exit.split

omp.par.exit.split:                               ; preds = %omp.par.outlined.exit
  %30 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %9, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %30, ptr %4, align 8, !tbaa !8
  %31 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i64 0, i32 0
  %32 = load i64, ptr %31, align 8, !tbaa !8
  %33 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i64 0, i32 1
  %34 = load i64, ptr %33, align 8, !tbaa !8
  %35 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i64 0, i32 2
  %36 = load i64, ptr %35, align 8, !tbaa !8
  %37 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 0
  %38 = load ptr, ptr %37, align 8, !tbaa !8
  %39 = sub i64 1, %32
  %40 = getelementptr double, ptr %38, i64 %39
  %41 = load double, ptr %40, align 8, !tbaa !4
  %42 = load i32, ptr %0, align 4, !tbaa !4
  %43 = sext i32 %42 to i64
  %44 = sub i64 %43, %32
  %45 = getelementptr double, ptr %38, i64 %44
  %46 = load double, ptr %45, align 8, !tbaa !4
  %47 = fadd contract double %41, %46
  store double %47, ptr %1, align 8, !tbaa !4
  %48 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %9, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %48, ptr %3, align 8, !tbaa !8
  %49 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i32 0, i32 0
  %50 = load ptr, ptr %49, align 8, !tbaa !8
  call void @free(ptr %50)
  %51 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %8, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %51, ptr %9, align 8, !tbaa !8
  ret void
}

; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %gep_ = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 0
  %loadgep_ = load ptr, ptr %gep_, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %tid.addr.local = alloca i32, align 4
  %1 = load i32, ptr %tid.addr, align 4
  store i32 %1, ptr %tid.addr.local, align 4
  %tid = load i32, ptr %tid.addr.local, align 4
  br label %omp.par.region

omp.par.region:                                   ; preds = %omp.par.entry
  br label %omp.par.region1

omp.par.region1:                                  ; preds = %omp.par.region
  %2 = alloca i32, i64 1, align 4
  %3 = alloca i32, i64 1, align 4
  %4 = alloca i32, i64 1, align 4
  %5 = alloca i32, i64 1, align 4
  %6 = alloca i32, i64 1, align 4
  %7 = alloca i32, i64 1, align 4
  %8 = call i32 @omp_get_thread_num()
  store i32 %8, ptr %3, align 4, !tbaa !4
  %9 = call i32 @omp_get_num_threads()
  store i32 %9, ptr %4, align 4, !tbaa !4
  %10 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %11 = load i32, ptr %4, align 4, !tbaa !4
  %12 = sdiv i32 %10, %11
  store i32 %12, ptr %7, align 4, !tbaa !4
  %13 = load i32, ptr %3, align 4, !tbaa !4
  %14 = load i32, ptr %7, align 4, !tbaa !4
  %15 = mul i32 %13, %14
  %16 = add i32 %15, 1
  store i32 %16, ptr %5, align 4, !tbaa !4
  %17 = load i32, ptr %3, align 4, !tbaa !4
  %18 = load i32, ptr %4, align 4, !tbaa !4
  %19 = sub i32 %18, 1
  %20 = icmp eq i32 %17, %19
  br i1 %20, label %omp.par.region2, label %omp.par.region3

omp.par.region3:                                  ; preds = %omp.par.region1
  %21 = load i32, ptr %5, align 4, !tbaa !4
  %22 = load i32, ptr %7, align 4, !tbaa !4
  %23 = add i32 %21, %22
  store i32 %23, ptr %6, align 4, !tbaa !4
  br label %omp.par.region4

omp.par.region4:                                  ; preds = %omp.par.region2, %omp.par.region3
  %24 = load i32, ptr %5, align 4, !tbaa !4
  %25 = sext i32 %24 to i64
  %26 = load i32, ptr %6, align 4, !tbaa !4
  %27 = sext i32 %26 to i64
  %28 = trunc i64 %25 to i32
  %29 = sub i64 %27, %25
  %30 = add i64 %29, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.region4
  %31 = phi i32 [ %66, %omp.par.region6 ], [ %28, %omp.par.region4 ]
  %32 = phi i64 [ %67, %omp.par.region6 ], [ %30, %omp.par.region4 ]
  %33 = icmp sgt i64 %32, 0
  br i1 %33, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  store i32 %31, ptr %2, align 4, !tbaa !4
  br label %omp.region.cont

omp.region.cont:                                  ; preds = %omp.par.region7
  br label %omp.par.pre_finalize

omp.par.pre_finalize:                             ; preds = %omp.region.cont
  br label %omp.par.outlined.exit.exitStub

omp.par.region6:                                  ; preds = %omp.par.region5
  store i32 %31, ptr %2, align 4, !tbaa !4
  %34 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %35 = sitofp i32 %34 to float
  %36 = fdiv contract float 1.000000e+00, %35
  %37 = fpext float %36 to double
  %38 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %38, ptr %loadgep_4, align 8, !tbaa !8
  %39 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 0
  %40 = load i64, ptr %39, align 8, !tbaa !8
  %41 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 1
  %42 = load i64, ptr %41, align 8, !tbaa !8
  %43 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 2
  %44 = load i64, ptr %43, align 8, !tbaa !8
  %45 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 0
  %46 = load ptr, ptr %45, align 8, !tbaa !8
  %47 = load i32, ptr %2, align 4, !tbaa !4
  %48 = sext i32 %47 to i64
  %49 = sub i64 %48, %40
  %50 = getelementptr double, ptr %46, i64 %49
  store double %37, ptr %50, align 8, !tbaa !4
  %51 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %51, ptr %loadgep_6, align 8, !tbaa !8
  %52 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 0
  %53 = load i64, ptr %52, align 8, !tbaa !8
  %54 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 1
  %55 = load i64, ptr %54, align 8, !tbaa !8
  %56 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 2
  %57 = load i64, ptr %56, align 8, !tbaa !8
  %58 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 0
  %59 = load ptr, ptr %58, align 8, !tbaa !8
  %60 = load i32, ptr %2, align 4, !tbaa !4
  %61 = sext i32 %60 to i64
  %62 = sub i64 %61, %53
  %63 = getelementptr double, ptr %59, i64 %62
  %64 = load double, ptr %63, align 8, !tbaa !4
  store double %64, ptr %loadgep_8, align 8, !tbaa !4
  %65 = load i32, ptr %2, align 4, !tbaa !4
  %66 = add i32 %65, 1
  %67 = sub i64 %32, 1
  br label %omp.par.region5

omp.par.region2:                                  ; preds = %omp.par.region1
  %68 = load i32, ptr %loadgep_, align 4, !tbaa !4
  store i32 %68, ptr %6, align 4, !tbaa !4
  br label %omp.par.region4

omp.par.outlined.exit.exitStub:                   ; preds = %omp.par.pre_finalize
  ret void
}

declare ptr @_FortranAioBeginExternalFormattedOutput(ptr, i64, ptr, i32, ptr, i32)

declare zeroext i1 @_FortranAioOutputAscii(ptr, ptr, i64)

declare zeroext i1 @_FortranAioOutputInteger32(ptr, i32)

declare zeroext i1 @_FortranAioOutputReal64(ptr, double)

declare i32 @_FortranAioEndIoStatement(ptr)

declare i32 @omp_get_thread_num()

declare i32 @omp_get_num_threads()

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn
declare ptr @llvm.stacksave() #3

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn
declare void @llvm.stackrestore(ptr) #3

; Function Attrs: nounwind
declare i32 @__kmpc_global_thread_num(ptr) #4

; Function Attrs: nounwind
declare !callback !10 void @__kmpc_fork_call(ptr, i32, ptr, ...) #4

attributes #0 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #1 = { mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #2 = { norecurse nounwind }
attributes #3 = { mustprogress nocallback nofree nosync nounwind willreturn }
attributes #4 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i32 7, !"openmp", i32 11}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{!5, !5, i64 0}
!5 = !{!"any data access", !6, i64 0}
!6 = !{!"any access", !7, i64 0}
!7 = !{!"Flang Type TBAA Root"}
!8 = !{!9, !9, i64 0}
!9 = !{!"descriptor member", !6, i64 0}
!10 = !{!11}
!11 = !{i64 2, i64 -1, i64 -1, i1 true}
*** IR Dump After CoroEarlyPass on [module] ***
; ModuleID = 'FIRModule'
source_filename = "FIRModule"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.ident_t = type { i32, i32, i32, i32, ptr }

@_QMomp_libEComp_allocator_handle_kind = external constant i32
@_QMomp_libEComp_alloctrait_key_kind = external constant i32
@_QMomp_libEComp_alloctrait_val_kind = external constant i32
@_QMomp_libEComp_allow_completion_event = external constant i32
@_QMomp_libEComp_atk_access = external constant i32
@_QMomp_libEComp_atk_alignment = external constant i32
@_QMomp_libEComp_atk_fallback = external constant i32
@_QMomp_libEComp_atk_fb_data = external constant i32
@_QMomp_libEComp_atk_partition = external constant i32
@_QMomp_libEComp_atk_pinned = external constant i32
@_QMomp_libEComp_atk_pool_size = external constant i32
@_QMomp_libEComp_atk_sync_hint = external constant i32
@_QMomp_libEComp_atv_abort_fb = external constant i32
@_QMomp_libEComp_atv_all = external constant i32
@_QMomp_libEComp_atv_allocator_fb = external constant i32
@_QMomp_libEComp_atv_blocked = external constant i32
@_QMomp_libEComp_atv_cgroup = external constant i32
@_QMomp_libEComp_atv_contended = external constant i32
@_QMomp_libEComp_atv_default = external constant i32
@_QMomp_libEComp_atv_default_mem_fb = external constant i32
@_QMomp_libEComp_atv_environment = external constant i32
@_QMomp_libEComp_atv_false = external constant i32
@_QMomp_libEComp_atv_interleaved = external constant i32
@_QMomp_libEComp_atv_nearest = external constant i32
@_QMomp_libEComp_atv_null_fb = external constant i32
@_QMomp_libEComp_atv_private = external constant i32
@_QMomp_libEComp_atv_pteam = external constant i32
@_QMomp_libEComp_atv_sequential = external constant i32
@_QMomp_libEComp_atv_thread = external constant i32
@_QMomp_libEComp_atv_true = external constant i32
@_QMomp_libEComp_atv_uncontended = external constant i32
@_QMomp_libEComp_cgroup_mem_alloc = external constant i32
@_QMomp_libEComp_const_mem_alloc = external constant i32
@_QMomp_libEComp_const_mem_space = external constant i32
@_QMomp_libEComp_default_mem_alloc = external constant i32
@_QMomp_libEComp_default_mem_space = external constant i32
@_QMomp_libEComp_depend_kind = external constant i32
@_QMomp_libEComp_event_handle_kind = external constant i32
@_QMomp_libEComp_high_bw_mem_alloc = external constant i32
@_QMomp_libEComp_high_bw_mem_space = external constant i32
@_QMomp_libEComp_integer_kind = external constant i32
@_QMomp_libEComp_large_cap_mem_alloc = external constant i32
@_QMomp_libEComp_large_cap_mem_space = external constant i32
@_QMomp_libEComp_lock_hint_contended = external constant i32
@_QMomp_libEComp_lock_hint_kind = external constant i32
@_QMomp_libEComp_lock_hint_none = external constant i32
@_QMomp_libEComp_lock_hint_nonspeculative = external constant i32
@_QMomp_libEComp_lock_hint_speculative = external constant i32
@_QMomp_libEComp_lock_hint_uncontended = external constant i32
@_QMomp_libEComp_lock_kind = external constant i32
@_QMomp_libEComp_logical_kind = external constant i32
@_QMomp_libEComp_low_lat_mem_alloc = external constant i32
@_QMomp_libEComp_low_lat_mem_space = external constant i32
@_QMomp_libEComp_memspace_handle_kind = external constant i32
@_QMomp_libEComp_nest_lock_kind = external constant i32
@_QMomp_libEComp_null_allocator = external constant i32
@_QMomp_libEComp_pause_hard = external constant i32
@_QMomp_libEComp_pause_resource_kind = external constant i32
@_QMomp_libEComp_pause_soft = external constant i32
@_QMomp_libEComp_proc_bind_close = external constant i32
@_QMomp_libEComp_proc_bind_false = external constant i32
@_QMomp_libEComp_proc_bind_kind = external constant i32
@_QMomp_libEComp_proc_bind_master = external constant i32
@_QMomp_libEComp_proc_bind_spread = external constant i32
@_QMomp_libEComp_proc_bind_true = external constant i32
@_QMomp_libEComp_pteam_mem_alloc = external constant i32
@_QMomp_libEComp_sched_auto = external constant i32
@_QMomp_libEComp_sched_dynamic = external constant i32
@_QMomp_libEComp_sched_guided = external constant i32
@_QMomp_libEComp_sched_kind = external constant i32
@_QMomp_libEComp_sched_static = external constant i32
@_QMomp_libEComp_sync_hint_contended = external constant i32
@_QMomp_libEComp_sync_hint_kind = external constant i32
@_QMomp_libEComp_sync_hint_none = external constant i32
@_QMomp_libEComp_sync_hint_nonspeculative = external constant i32
@_QMomp_libEComp_sync_hint_speculative = external constant i32
@_QMomp_libEComp_sync_hint_uncontended = external constant i32
@_QMomp_libEComp_task_fulfill_event = external constant i32
@_QMomp_libEComp_thread_mem_alloc = external constant i32
@_QMomp_libECopenmp_version = external constant i32
@_QQcl.28612C69372C612C6531332E36653229 = internal constant [16 x i8] c"(a,i7,a,e13.6e2)"
@_QQcl.21557d42704c5c1f18a68415065290ee = internal constant [50 x i8] c"/g/g92/rydahl1/flangtests/src/parallel_region.f90\00"
@_QQcl.54686520726573756C74206F6620286172722831292B61727228 = internal constant [26 x i8] c"The result of (arr(1)+arr("
@_QQcl.2920697320 = internal constant [5 x i8] c") is "
@_QQEnvironmentDefaults = constant ptr null
@0 = private unnamed_addr constant [23 x i8] c";unknown;unknown;0;0;;\00", align 1
@1 = private unnamed_addr constant %struct.ident_t { i32 0, i32 2, i32 0, i32 22, ptr @0 }, align 8

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite)
declare noalias noundef ptr @malloc(i64 noundef) #0

; Function Attrs: mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite)
declare void @free(ptr allocptr nocapture noundef) #1

define void @_QQmain() {
  %1 = alloca i32, i64 1, align 4
  %2 = alloca double, i64 1, align 8
  %3 = alloca double, i64 1, align 8
  store i32 1048576, ptr %1, align 4, !tbaa !4
  call void @_QFPomp_subroutine(ptr %1, ptr %2)
  %4 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %5 = call i1 @_FortranAioOutputAscii(ptr %4, ptr @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %6 = load i32, ptr %1, align 4, !tbaa !4
  %7 = call i1 @_FortranAioOutputInteger32(ptr %4, i32 %6)
  %8 = call i1 @_FortranAioOutputAscii(ptr %4, ptr @_QQcl.2920697320, i64 5)
  %9 = load double, ptr %2, align 8, !tbaa !4
  %10 = call i1 @_FortranAioOutputReal64(ptr %4, double %9)
  %11 = call i32 @_FortranAioEndIoStatement(ptr %4)
  ret void
}

define void @_QFPomp_subroutine(ptr %0, ptr %1) {
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %5 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %6 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %7 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %8 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %9 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, i64 1, align 8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } { ptr null, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), i32 20180515, i8 1, i8 28, i8 2, i8 0, [1 x [3 x i64]] [[3 x i64] [i64 1, i64 0, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64)]] }, ptr %8, align 8, !tbaa !8
  %10 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %8, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %10, ptr %9, align 8, !tbaa !8
  %11 = alloca i32, i64 1, align 4
  %12 = alloca i32, i64 1, align 4
  %13 = alloca i32, i64 1, align 4
  %14 = alloca i32, i64 1, align 4
  %15 = alloca i32, i64 1, align 4
  %16 = alloca double, i64 1, align 8
  %17 = alloca i32, i64 1, align 4
  %18 = load i32, ptr %0, align 4, !tbaa !4
  %19 = sext i32 %18 to i64
  %20 = icmp sgt i64 %19, 0
  %21 = select i1 %20, i64 %19, i64 0
  %22 = mul i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), %21
  %23 = call ptr @malloc(i64 %22)
  %24 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } { ptr undef, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), i32 20180515, i8 1, i8 28, i8 2, i8 0, [1 x [3 x i64]] [[3 x i64] [i64 1, i64 undef, i64 undef]] }, i64 %21, 7, 0, 1
  %25 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %24, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), 7, 0, 2
  %26 = mul i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), %21
  %27 = mul i64 1, %21
  %28 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %25, ptr %23, 0
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %28, ptr %7, align 8, !tbaa !8
  %29 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %7, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %29, ptr %9, align 8, !tbaa !8
  br label %entry

entry:                                            ; preds = %2
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr @1)
  br label %omp_parallel

omp_parallel:                                     ; preds = %entry
  %gep_ = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 0
  store ptr %0, ptr %gep_, align 8
  %gep_8 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 1
  store ptr %9, ptr %gep_8, align 8
  %gep_9 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 2
  store ptr %6, ptr %gep_9, align 8
  %gep_10 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 3
  store ptr %5, ptr %gep_10, align 8
  %gep_11 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 4
  store ptr %16, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @1, i32 1, ptr @_QFPomp_subroutine..omp_par, ptr %structArg)
  br label %omp.par.outlined.exit

omp.par.outlined.exit:                            ; preds = %omp_parallel
  br label %omp.par.exit.split

omp.par.exit.split:                               ; preds = %omp.par.outlined.exit
  %30 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %9, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %30, ptr %4, align 8, !tbaa !8
  %31 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i64 0, i32 0
  %32 = load i64, ptr %31, align 8, !tbaa !8
  %33 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i64 0, i32 1
  %34 = load i64, ptr %33, align 8, !tbaa !8
  %35 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i64 0, i32 2
  %36 = load i64, ptr %35, align 8, !tbaa !8
  %37 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 0
  %38 = load ptr, ptr %37, align 8, !tbaa !8
  %39 = sub i64 1, %32
  %40 = getelementptr double, ptr %38, i64 %39
  %41 = load double, ptr %40, align 8, !tbaa !4
  %42 = load i32, ptr %0, align 4, !tbaa !4
  %43 = sext i32 %42 to i64
  %44 = sub i64 %43, %32
  %45 = getelementptr double, ptr %38, i64 %44
  %46 = load double, ptr %45, align 8, !tbaa !4
  %47 = fadd contract double %41, %46
  store double %47, ptr %1, align 8, !tbaa !4
  %48 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %9, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %48, ptr %3, align 8, !tbaa !8
  %49 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i32 0, i32 0
  %50 = load ptr, ptr %49, align 8, !tbaa !8
  call void @free(ptr %50)
  %51 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %8, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %51, ptr %9, align 8, !tbaa !8
  ret void
}

; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %gep_ = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 0
  %loadgep_ = load ptr, ptr %gep_, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %tid.addr.local = alloca i32, align 4
  %1 = load i32, ptr %tid.addr, align 4
  store i32 %1, ptr %tid.addr.local, align 4
  %tid = load i32, ptr %tid.addr.local, align 4
  br label %omp.par.region

omp.par.region:                                   ; preds = %omp.par.entry
  br label %omp.par.region1

omp.par.region1:                                  ; preds = %omp.par.region
  %2 = alloca i32, i64 1, align 4
  %3 = alloca i32, i64 1, align 4
  %4 = alloca i32, i64 1, align 4
  %5 = alloca i32, i64 1, align 4
  %6 = alloca i32, i64 1, align 4
  %7 = alloca i32, i64 1, align 4
  %8 = call i32 @omp_get_thread_num()
  store i32 %8, ptr %3, align 4, !tbaa !4
  %9 = call i32 @omp_get_num_threads()
  store i32 %9, ptr %4, align 4, !tbaa !4
  %10 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %11 = load i32, ptr %4, align 4, !tbaa !4
  %12 = sdiv i32 %10, %11
  store i32 %12, ptr %7, align 4, !tbaa !4
  %13 = load i32, ptr %3, align 4, !tbaa !4
  %14 = load i32, ptr %7, align 4, !tbaa !4
  %15 = mul i32 %13, %14
  %16 = add i32 %15, 1
  store i32 %16, ptr %5, align 4, !tbaa !4
  %17 = load i32, ptr %3, align 4, !tbaa !4
  %18 = load i32, ptr %4, align 4, !tbaa !4
  %19 = sub i32 %18, 1
  %20 = icmp eq i32 %17, %19
  br i1 %20, label %omp.par.region2, label %omp.par.region3

omp.par.region3:                                  ; preds = %omp.par.region1
  %21 = load i32, ptr %5, align 4, !tbaa !4
  %22 = load i32, ptr %7, align 4, !tbaa !4
  %23 = add i32 %21, %22
  store i32 %23, ptr %6, align 4, !tbaa !4
  br label %omp.par.region4

omp.par.region4:                                  ; preds = %omp.par.region2, %omp.par.region3
  %24 = load i32, ptr %5, align 4, !tbaa !4
  %25 = sext i32 %24 to i64
  %26 = load i32, ptr %6, align 4, !tbaa !4
  %27 = sext i32 %26 to i64
  %28 = trunc i64 %25 to i32
  %29 = sub i64 %27, %25
  %30 = add i64 %29, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.region4
  %31 = phi i32 [ %66, %omp.par.region6 ], [ %28, %omp.par.region4 ]
  %32 = phi i64 [ %67, %omp.par.region6 ], [ %30, %omp.par.region4 ]
  %33 = icmp sgt i64 %32, 0
  br i1 %33, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  store i32 %31, ptr %2, align 4, !tbaa !4
  br label %omp.region.cont

omp.region.cont:                                  ; preds = %omp.par.region7
  br label %omp.par.pre_finalize

omp.par.pre_finalize:                             ; preds = %omp.region.cont
  br label %omp.par.outlined.exit.exitStub

omp.par.region6:                                  ; preds = %omp.par.region5
  store i32 %31, ptr %2, align 4, !tbaa !4
  %34 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %35 = sitofp i32 %34 to float
  %36 = fdiv contract float 1.000000e+00, %35
  %37 = fpext float %36 to double
  %38 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %38, ptr %loadgep_4, align 8, !tbaa !8
  %39 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 0
  %40 = load i64, ptr %39, align 8, !tbaa !8
  %41 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 1
  %42 = load i64, ptr %41, align 8, !tbaa !8
  %43 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 2
  %44 = load i64, ptr %43, align 8, !tbaa !8
  %45 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 0
  %46 = load ptr, ptr %45, align 8, !tbaa !8
  %47 = load i32, ptr %2, align 4, !tbaa !4
  %48 = sext i32 %47 to i64
  %49 = sub i64 %48, %40
  %50 = getelementptr double, ptr %46, i64 %49
  store double %37, ptr %50, align 8, !tbaa !4
  %51 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %51, ptr %loadgep_6, align 8, !tbaa !8
  %52 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 0
  %53 = load i64, ptr %52, align 8, !tbaa !8
  %54 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 1
  %55 = load i64, ptr %54, align 8, !tbaa !8
  %56 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 2
  %57 = load i64, ptr %56, align 8, !tbaa !8
  %58 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 0
  %59 = load ptr, ptr %58, align 8, !tbaa !8
  %60 = load i32, ptr %2, align 4, !tbaa !4
  %61 = sext i32 %60 to i64
  %62 = sub i64 %61, %53
  %63 = getelementptr double, ptr %59, i64 %62
  %64 = load double, ptr %63, align 8, !tbaa !4
  store double %64, ptr %loadgep_8, align 8, !tbaa !4
  %65 = load i32, ptr %2, align 4, !tbaa !4
  %66 = add i32 %65, 1
  %67 = sub i64 %32, 1
  br label %omp.par.region5

omp.par.region2:                                  ; preds = %omp.par.region1
  %68 = load i32, ptr %loadgep_, align 4, !tbaa !4
  store i32 %68, ptr %6, align 4, !tbaa !4
  br label %omp.par.region4

omp.par.outlined.exit.exitStub:                   ; preds = %omp.par.pre_finalize
  ret void
}

declare ptr @_FortranAioBeginExternalFormattedOutput(ptr, i64, ptr, i32, ptr, i32)

declare zeroext i1 @_FortranAioOutputAscii(ptr, ptr, i64)

declare zeroext i1 @_FortranAioOutputInteger32(ptr, i32)

declare zeroext i1 @_FortranAioOutputReal64(ptr, double)

declare i32 @_FortranAioEndIoStatement(ptr)

declare i32 @omp_get_thread_num()

declare i32 @omp_get_num_threads()

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn
declare ptr @llvm.stacksave() #3

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn
declare void @llvm.stackrestore(ptr) #3

; Function Attrs: nounwind
declare i32 @__kmpc_global_thread_num(ptr) #4

; Function Attrs: nounwind
declare !callback !10 void @__kmpc_fork_call(ptr, i32, ptr, ...) #4

attributes #0 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #1 = { mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #2 = { norecurse nounwind }
attributes #3 = { mustprogress nocallback nofree nosync nounwind willreturn }
attributes #4 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i32 7, !"openmp", i32 11}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{!5, !5, i64 0}
!5 = !{!"any data access", !6, i64 0}
!6 = !{!"any access", !7, i64 0}
!7 = !{!"Flang Type TBAA Root"}
!8 = !{!9, !9, i64 0}
!9 = !{!"descriptor member", !6, i64 0}
!10 = !{!11}
!11 = !{i64 2, i64 -1, i64 -1, i1 true}
*** IR Dump After LowerExpectIntrinsicPass on _QQmain ***
define void @_QQmain() {
  %1 = alloca i32, i64 1, align 4
  %2 = alloca double, i64 1, align 8
  %3 = alloca double, i64 1, align 8
  store i32 1048576, ptr %1, align 4, !tbaa !4
  call void @_QFPomp_subroutine(ptr %1, ptr %2)
  %4 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %5 = call i1 @_FortranAioOutputAscii(ptr %4, ptr @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %6 = load i32, ptr %1, align 4, !tbaa !4
  %7 = call i1 @_FortranAioOutputInteger32(ptr %4, i32 %6)
  %8 = call i1 @_FortranAioOutputAscii(ptr %4, ptr @_QQcl.2920697320, i64 5)
  %9 = load double, ptr %2, align 8, !tbaa !4
  %10 = call i1 @_FortranAioOutputReal64(ptr %4, double %9)
  %11 = call i32 @_FortranAioEndIoStatement(ptr %4)
  ret void
}
*** IR Dump After SimplifyCFGPass on _QQmain ***
define void @_QQmain() {
  %1 = alloca i32, i64 1, align 4
  %2 = alloca double, i64 1, align 8
  %3 = alloca double, i64 1, align 8
  store i32 1048576, ptr %1, align 4, !tbaa !4
  call void @_QFPomp_subroutine(ptr %1, ptr %2)
  %4 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %5 = call i1 @_FortranAioOutputAscii(ptr %4, ptr @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %6 = load i32, ptr %1, align 4, !tbaa !4
  %7 = call i1 @_FortranAioOutputInteger32(ptr %4, i32 %6)
  %8 = call i1 @_FortranAioOutputAscii(ptr %4, ptr @_QQcl.2920697320, i64 5)
  %9 = load double, ptr %2, align 8, !tbaa !4
  %10 = call i1 @_FortranAioOutputReal64(ptr %4, double %9)
  %11 = call i32 @_FortranAioEndIoStatement(ptr %4)
  ret void
}
*** IR Dump After SROAPass on _QQmain ***
define void @_QQmain() {
  %1 = alloca i32, i64 1, align 4
  %2 = alloca double, i64 1, align 8
  store i32 1048576, ptr %1, align 4, !tbaa !4
  call void @_QFPomp_subroutine(ptr %1, ptr %2)
  %3 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %4 = call i1 @_FortranAioOutputAscii(ptr %3, ptr @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %5 = load i32, ptr %1, align 4, !tbaa !4
  %6 = call i1 @_FortranAioOutputInteger32(ptr %3, i32 %5)
  %7 = call i1 @_FortranAioOutputAscii(ptr %3, ptr @_QQcl.2920697320, i64 5)
  %8 = load double, ptr %2, align 8, !tbaa !4
  %9 = call i1 @_FortranAioOutputReal64(ptr %3, double %8)
  %10 = call i32 @_FortranAioEndIoStatement(ptr %3)
  ret void
}
*** IR Dump After EarlyCSEPass on _QQmain ***
define void @_QQmain() {
  %1 = alloca i32, i64 1, align 4
  %2 = alloca double, i64 1, align 8
  store i32 1048576, ptr %1, align 4, !tbaa !4
  call void @_QFPomp_subroutine(ptr %1, ptr %2)
  %3 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %4 = call i1 @_FortranAioOutputAscii(ptr %3, ptr @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %5 = load i32, ptr %1, align 4, !tbaa !4
  %6 = call i1 @_FortranAioOutputInteger32(ptr %3, i32 %5)
  %7 = call i1 @_FortranAioOutputAscii(ptr %3, ptr @_QQcl.2920697320, i64 5)
  %8 = load double, ptr %2, align 8, !tbaa !4
  %9 = call i1 @_FortranAioOutputReal64(ptr %3, double %8)
  %10 = call i32 @_FortranAioEndIoStatement(ptr %3)
  ret void
}
*** IR Dump After CallSiteSplittingPass on _QQmain ***
define void @_QQmain() {
  %1 = alloca i32, i64 1, align 4
  %2 = alloca double, i64 1, align 8
  store i32 1048576, ptr %1, align 4, !tbaa !4
  call void @_QFPomp_subroutine(ptr %1, ptr %2)
  %3 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %4 = call i1 @_FortranAioOutputAscii(ptr %3, ptr @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %5 = load i32, ptr %1, align 4, !tbaa !4
  %6 = call i1 @_FortranAioOutputInteger32(ptr %3, i32 %5)
  %7 = call i1 @_FortranAioOutputAscii(ptr %3, ptr @_QQcl.2920697320, i64 5)
  %8 = load double, ptr %2, align 8, !tbaa !4
  %9 = call i1 @_FortranAioOutputReal64(ptr %3, double %8)
  %10 = call i32 @_FortranAioEndIoStatement(ptr %3)
  ret void
}
*** IR Dump After LowerExpectIntrinsicPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) {
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %5 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %6 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %7 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %8 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %9 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, i64 1, align 8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } { ptr null, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), i32 20180515, i8 1, i8 28, i8 2, i8 0, [1 x [3 x i64]] [[3 x i64] [i64 1, i64 0, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64)]] }, ptr %8, align 8, !tbaa !8
  %10 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %8, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %10, ptr %9, align 8, !tbaa !8
  %11 = alloca i32, i64 1, align 4
  %12 = alloca i32, i64 1, align 4
  %13 = alloca i32, i64 1, align 4
  %14 = alloca i32, i64 1, align 4
  %15 = alloca i32, i64 1, align 4
  %16 = alloca double, i64 1, align 8
  %17 = alloca i32, i64 1, align 4
  %18 = load i32, ptr %0, align 4, !tbaa !4
  %19 = sext i32 %18 to i64
  %20 = icmp sgt i64 %19, 0
  %21 = select i1 %20, i64 %19, i64 0
  %22 = mul i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), %21
  %23 = call ptr @malloc(i64 %22)
  %24 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } { ptr undef, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), i32 20180515, i8 1, i8 28, i8 2, i8 0, [1 x [3 x i64]] [[3 x i64] [i64 1, i64 undef, i64 undef]] }, i64 %21, 7, 0, 1
  %25 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %24, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), 7, 0, 2
  %26 = mul i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), %21
  %27 = mul i64 1, %21
  %28 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %25, ptr %23, 0
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %28, ptr %7, align 8, !tbaa !8
  %29 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %7, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %29, ptr %9, align 8, !tbaa !8
  br label %entry

entry:                                            ; preds = %2
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr @1)
  br label %omp_parallel

omp_parallel:                                     ; preds = %entry
  %gep_ = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 0
  store ptr %0, ptr %gep_, align 8
  %gep_8 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 1
  store ptr %9, ptr %gep_8, align 8
  %gep_9 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 2
  store ptr %6, ptr %gep_9, align 8
  %gep_10 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 3
  store ptr %5, ptr %gep_10, align 8
  %gep_11 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 4
  store ptr %16, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @1, i32 1, ptr @_QFPomp_subroutine..omp_par, ptr %structArg)
  br label %omp.par.outlined.exit

omp.par.outlined.exit:                            ; preds = %omp_parallel
  br label %omp.par.exit.split

omp.par.exit.split:                               ; preds = %omp.par.outlined.exit
  %30 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %9, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %30, ptr %4, align 8, !tbaa !8
  %31 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i64 0, i32 0
  %32 = load i64, ptr %31, align 8, !tbaa !8
  %33 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i64 0, i32 1
  %34 = load i64, ptr %33, align 8, !tbaa !8
  %35 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i64 0, i32 2
  %36 = load i64, ptr %35, align 8, !tbaa !8
  %37 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 0
  %38 = load ptr, ptr %37, align 8, !tbaa !8
  %39 = sub i64 1, %32
  %40 = getelementptr double, ptr %38, i64 %39
  %41 = load double, ptr %40, align 8, !tbaa !4
  %42 = load i32, ptr %0, align 4, !tbaa !4
  %43 = sext i32 %42 to i64
  %44 = sub i64 %43, %32
  %45 = getelementptr double, ptr %38, i64 %44
  %46 = load double, ptr %45, align 8, !tbaa !4
  %47 = fadd contract double %41, %46
  store double %47, ptr %1, align 8, !tbaa !4
  %48 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %9, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %48, ptr %3, align 8, !tbaa !8
  %49 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i32 0, i32 0
  %50 = load ptr, ptr %49, align 8, !tbaa !8
  call void @free(ptr %50)
  %51 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %8, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %51, ptr %9, align 8, !tbaa !8
  ret void
}
*** IR Dump After SimplifyCFGPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %5 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %6 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %7 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %8 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, i64 1, align 8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } { ptr null, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), i32 20180515, i8 1, i8 28, i8 2, i8 0, [1 x [3 x i64]] [[3 x i64] [i64 1, i64 0, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64)]] }, ptr %7, align 8, !tbaa !8
  %9 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %7, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %9, ptr %8, align 8, !tbaa !8
  %10 = alloca i32, i64 1, align 4
  %11 = alloca i32, i64 1, align 4
  %12 = alloca i32, i64 1, align 4
  %13 = alloca i32, i64 1, align 4
  %14 = alloca i32, i64 1, align 4
  %15 = alloca double, i64 1, align 8
  %16 = alloca i32, i64 1, align 4
  %17 = load i32, ptr %0, align 4, !tbaa !4
  %18 = sext i32 %17 to i64
  %19 = icmp sgt i64 %18, 0
  %20 = select i1 %19, i64 %18, i64 0
  %21 = mul i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), %20
  %22 = call ptr @malloc(i64 %21)
  %23 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } { ptr undef, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), i32 20180515, i8 1, i8 28, i8 2, i8 0, [1 x [3 x i64]] [[3 x i64] [i64 1, i64 undef, i64 undef]] }, i64 %20, 7, 0, 1
  %24 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %23, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), 7, 0, 2
  %25 = mul i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), %20
  %26 = mul i64 1, %20
  %27 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %24, ptr %22, 0
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %27, ptr %6, align 8, !tbaa !8
  %28 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %6, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %28, ptr %8, align 8, !tbaa !8
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr @1)
  %gep_ = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 0
  store ptr %0, ptr %gep_, align 8
  %gep_8 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 1
  store ptr %8, ptr %gep_8, align 8
  %gep_9 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 2
  store ptr %5, ptr %gep_9, align 8
  %gep_10 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 3
  store ptr %4, ptr %gep_10, align 8
  %gep_11 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 4
  store ptr %15, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @1, i32 1, ptr @_QFPomp_subroutine..omp_par, ptr %structArg)
  %29 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %8, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %29, ptr %3, align 8, !tbaa !8
  %30 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i32 0, i32 7, i64 0, i32 0
  %31 = load i64, ptr %30, align 8, !tbaa !8
  %32 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i32 0, i32 7, i64 0, i32 1
  %33 = load i64, ptr %32, align 8, !tbaa !8
  %34 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i32 0, i32 7, i64 0, i32 2
  %35 = load i64, ptr %34, align 8, !tbaa !8
  %36 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i32 0, i32 0
  %37 = load ptr, ptr %36, align 8, !tbaa !8
  %38 = sub i64 1, %31
  %39 = getelementptr double, ptr %37, i64 %38
  %40 = load double, ptr %39, align 8, !tbaa !4
  %41 = load i32, ptr %0, align 4, !tbaa !4
  %42 = sext i32 %41 to i64
  %43 = sub i64 %42, %31
  %44 = getelementptr double, ptr %37, i64 %43
  %45 = load double, ptr %44, align 8, !tbaa !4
  %46 = fadd contract double %40, %45
  store double %46, ptr %1, align 8, !tbaa !4
  %47 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %8, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %47, ptr %2, align 8, !tbaa !8
  %48 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %2, i32 0, i32 0
  %49 = load ptr, ptr %48, align 8, !tbaa !8
  call void @free(ptr %49)
  %50 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %7, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %50, ptr %8, align 8, !tbaa !8
  ret void
}
*** IR Dump After SROAPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, i64 1, align 8
  %.fca.0.insert104 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } poison, ptr null, 0
  %.fca.1.insert107 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.0.insert104, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), 1
  %.fca.2.insert110 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.1.insert107, i32 20180515, 2
  %.fca.3.insert113 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.2.insert110, i8 1, 3
  %.fca.4.insert116 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.3.insert113, i8 28, 4
  %.fca.5.insert119 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.4.insert116, i8 2, 5
  %.fca.6.insert122 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.5.insert119, i8 0, 6
  %.fca.7.0.0.insert125 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.6.insert122, i64 1, 7, 0, 0
  %.fca.7.0.1.insert128 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.0.insert125, i64 0, 7, 0, 1
  %.fca.7.0.2.insert131 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.1.insert128, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), 7, 0, 2
  %.fca.0.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert131, 0
  %.fca.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 0
  store ptr %.fca.0.extract, ptr %.fca.0.gep, align 8, !tbaa !8
  %.fca.1.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert131, 1
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 1
  store i64 %.fca.1.extract, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert131, 2
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 2
  store i32 %.fca.2.extract, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert131, 3
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 3
  store i8 %.fca.3.extract, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert131, 4
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 4
  store i8 %.fca.4.extract, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert131, 5
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 5
  store i8 %.fca.5.extract, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert131, 6
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 6
  store i8 %.fca.6.extract, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert131, 7, 0, 0
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 0
  store i64 %.fca.7.0.0.extract, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert131, 7, 0, 1
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 1
  store i64 %.fca.7.0.1.extract, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert131, 7, 0, 2
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 2
  store i64 %.fca.7.0.2.extract, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, i64 1, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = sext i32 %6 to i64
  %8 = icmp sgt i64 %7, 0
  %9 = select i1 %8, i64 %7, i64 0
  %10 = mul i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), %9
  %11 = call ptr @malloc(i64 %10)
  %12 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } { ptr undef, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), i32 20180515, i8 1, i8 28, i8 2, i8 0, [1 x [3 x i64]] [[3 x i64] [i64 1, i64 undef, i64 undef]] }, i64 %9, 7, 0, 1
  %13 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %12, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), 7, 0, 2
  %14 = mul i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), %9
  %15 = mul i64 1, %9
  %16 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %13, ptr %11, 0
  %.fca.0.extract171 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %16, 0
  %.fca.1.extract173 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %16, 1
  %.fca.2.extract175 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %16, 2
  %.fca.3.extract177 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %16, 3
  %.fca.4.extract179 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %16, 4
  %.fca.5.extract181 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %16, 5
  %.fca.6.extract183 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %16, 6
  %.fca.7.0.0.extract185 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %16, 7, 0, 0
  %.fca.7.0.1.extract187 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %16, 7, 0, 1
  %.fca.7.0.2.extract189 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %16, 7, 0, 2
  %.fca.0.insert193 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } poison, ptr %.fca.0.extract171, 0
  %.fca.1.insert196 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.0.insert193, i64 %.fca.1.extract173, 1
  %.fca.2.insert199 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.1.insert196, i32 %.fca.2.extract175, 2
  %.fca.3.insert202 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.2.insert199, i8 %.fca.3.extract177, 3
  %.fca.4.insert205 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.3.insert202, i8 %.fca.4.extract179, 4
  %.fca.5.insert208 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.4.insert205, i8 %.fca.5.extract181, 5
  %.fca.6.insert211 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.5.insert208, i8 %.fca.6.extract183, 6
  %.fca.7.0.0.insert214 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.6.insert211, i64 %.fca.7.0.0.extract185, 7, 0, 0
  %.fca.7.0.1.insert217 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.0.insert214, i64 %.fca.7.0.1.extract187, 7, 0, 1
  %.fca.7.0.2.insert220 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.1.insert217, i64 %.fca.7.0.2.extract189, 7, 0, 2
  %.fca.0.extract12 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert220, 0
  %.fca.0.gep13 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 0
  store ptr %.fca.0.extract12, ptr %.fca.0.gep13, align 8, !tbaa !8
  %.fca.1.extract14 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert220, 1
  %.fca.1.gep15 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 1
  store i64 %.fca.1.extract14, ptr %.fca.1.gep15, align 8, !tbaa !8
  %.fca.2.extract16 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert220, 2
  %.fca.2.gep17 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 2
  store i32 %.fca.2.extract16, ptr %.fca.2.gep17, align 8, !tbaa !8
  %.fca.3.extract18 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert220, 3
  %.fca.3.gep19 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 3
  store i8 %.fca.3.extract18, ptr %.fca.3.gep19, align 4, !tbaa !8
  %.fca.4.extract20 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert220, 4
  %.fca.4.gep21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 4
  store i8 %.fca.4.extract20, ptr %.fca.4.gep21, align 1, !tbaa !8
  %.fca.5.extract22 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert220, 5
  %.fca.5.gep23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 5
  store i8 %.fca.5.extract22, ptr %.fca.5.gep23, align 2, !tbaa !8
  %.fca.6.extract24 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert220, 6
  %.fca.6.gep25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 6
  store i8 %.fca.6.extract24, ptr %.fca.6.gep25, align 1, !tbaa !8
  %.fca.7.0.0.extract26 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert220, 7, 0, 0
  %.fca.7.0.0.gep27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 0
  store i64 %.fca.7.0.0.extract26, ptr %.fca.7.0.0.gep27, align 8, !tbaa !8
  %.fca.7.0.1.extract28 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert220, 7, 0, 1
  %.fca.7.0.1.gep29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 1
  store i64 %.fca.7.0.1.extract28, ptr %.fca.7.0.1.gep29, align 8, !tbaa !8
  %.fca.7.0.2.extract30 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert220, 7, 0, 2
  %.fca.7.0.2.gep31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 2
  store i64 %.fca.7.0.2.extract30, ptr %.fca.7.0.2.gep31, align 8, !tbaa !8
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr @1)
  %gep_ = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 0
  store ptr %0, ptr %gep_, align 8
  %gep_8 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @1, i32 1, ptr @_QFPomp_subroutine..omp_par, ptr %structArg)
  %.fca.0.gep32 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 0
  %.fca.0.load = load ptr, ptr %.fca.0.gep32, align 8, !tbaa !8
  %.fca.0.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } poison, ptr %.fca.0.load, 0
  %.fca.1.gep33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 1
  %.fca.1.load = load i64, ptr %.fca.1.gep33, align 8, !tbaa !8
  %.fca.1.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.0.insert, i64 %.fca.1.load, 1
  %.fca.2.gep34 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 2
  %.fca.2.load = load i32, ptr %.fca.2.gep34, align 8, !tbaa !8
  %.fca.2.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.1.insert, i32 %.fca.2.load, 2
  %.fca.3.gep35 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 3
  %.fca.3.load = load i8, ptr %.fca.3.gep35, align 4, !tbaa !8
  %.fca.3.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.2.insert, i8 %.fca.3.load, 3
  %.fca.4.gep36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 4
  %.fca.4.load = load i8, ptr %.fca.4.gep36, align 1, !tbaa !8
  %.fca.4.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.3.insert, i8 %.fca.4.load, 4
  %.fca.5.gep37 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 5
  %.fca.5.load = load i8, ptr %.fca.5.gep37, align 2, !tbaa !8
  %.fca.5.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.4.insert, i8 %.fca.5.load, 5
  %.fca.6.gep38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 6
  %.fca.6.load = load i8, ptr %.fca.6.gep38, align 1, !tbaa !8
  %.fca.6.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.5.insert, i8 %.fca.6.load, 6
  %.fca.7.0.0.gep39 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 0
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep39, align 8, !tbaa !8
  %.fca.7.0.0.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.6.insert, i64 %.fca.7.0.0.load, 7, 0, 0
  %.fca.7.0.1.gep40 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 1
  %.fca.7.0.1.load = load i64, ptr %.fca.7.0.1.gep40, align 8, !tbaa !8
  %.fca.7.0.1.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.0.insert, i64 %.fca.7.0.1.load, 7, 0, 1
  %.fca.7.0.2.gep41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 2
  %.fca.7.0.2.load = load i64, ptr %.fca.7.0.2.gep41, align 8, !tbaa !8
  %.fca.7.0.2.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.1.insert, i64 %.fca.7.0.2.load, 7, 0, 2
  %.fca.7.0.2.insert.fca.0.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert, 0
  %.fca.7.0.2.insert.fca.1.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert, 1
  %.fca.7.0.2.insert.fca.2.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert, 2
  %.fca.7.0.2.insert.fca.3.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert, 3
  %.fca.7.0.2.insert.fca.4.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert, 4
  %.fca.7.0.2.insert.fca.5.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert, 5
  %.fca.7.0.2.insert.fca.6.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert, 6
  %.fca.7.0.2.insert.fca.7.0.0.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert, 7, 0, 0
  %.fca.7.0.2.insert.fca.7.0.1.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert, 7, 0, 1
  %.fca.7.0.2.insert.fca.7.0.2.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert, 7, 0, 2
  %17 = sub i64 1, %.fca.7.0.2.insert.fca.7.0.0.extract
  %18 = getelementptr double, ptr %.fca.7.0.2.insert.fca.0.extract, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !4
  %20 = load i32, ptr %0, align 4, !tbaa !4
  %21 = sext i32 %20 to i64
  %22 = sub i64 %21, %.fca.7.0.2.insert.fca.7.0.0.extract
  %23 = getelementptr double, ptr %.fca.7.0.2.insert.fca.0.extract, i64 %22
  %24 = load double, ptr %23, align 8, !tbaa !4
  %25 = fadd contract double %19, %24
  store double %25, ptr %1, align 8, !tbaa !4
  %.fca.0.gep42 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 0
  %.fca.0.load43 = load ptr, ptr %.fca.0.gep42, align 8, !tbaa !8
  %.fca.0.insert44 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } poison, ptr %.fca.0.load43, 0
  %.fca.1.gep45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 1
  %.fca.1.load46 = load i64, ptr %.fca.1.gep45, align 8, !tbaa !8
  %.fca.1.insert47 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.0.insert44, i64 %.fca.1.load46, 1
  %.fca.2.gep48 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 2
  %.fca.2.load49 = load i32, ptr %.fca.2.gep48, align 8, !tbaa !8
  %.fca.2.insert50 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.1.insert47, i32 %.fca.2.load49, 2
  %.fca.3.gep51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 3
  %.fca.3.load52 = load i8, ptr %.fca.3.gep51, align 4, !tbaa !8
  %.fca.3.insert53 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.2.insert50, i8 %.fca.3.load52, 3
  %.fca.4.gep54 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 4
  %.fca.4.load55 = load i8, ptr %.fca.4.gep54, align 1, !tbaa !8
  %.fca.4.insert56 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.3.insert53, i8 %.fca.4.load55, 4
  %.fca.5.gep57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 5
  %.fca.5.load58 = load i8, ptr %.fca.5.gep57, align 2, !tbaa !8
  %.fca.5.insert59 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.4.insert56, i8 %.fca.5.load58, 5
  %.fca.6.gep60 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 6
  %.fca.6.load61 = load i8, ptr %.fca.6.gep60, align 1, !tbaa !8
  %.fca.6.insert62 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.5.insert59, i8 %.fca.6.load61, 6
  %.fca.7.0.0.gep63 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 0
  %.fca.7.0.0.load64 = load i64, ptr %.fca.7.0.0.gep63, align 8, !tbaa !8
  %.fca.7.0.0.insert65 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.6.insert62, i64 %.fca.7.0.0.load64, 7, 0, 0
  %.fca.7.0.1.gep66 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 1
  %.fca.7.0.1.load67 = load i64, ptr %.fca.7.0.1.gep66, align 8, !tbaa !8
  %.fca.7.0.1.insert68 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.0.insert65, i64 %.fca.7.0.1.load67, 7, 0, 1
  %.fca.7.0.2.gep69 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 2
  %.fca.7.0.2.load70 = load i64, ptr %.fca.7.0.2.gep69, align 8, !tbaa !8
  %.fca.7.0.2.insert71 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.1.insert68, i64 %.fca.7.0.2.load70, 7, 0, 2
  %.fca.7.0.2.insert71.fca.0.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert71, 0
  %.fca.7.0.2.insert71.fca.1.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert71, 1
  %.fca.7.0.2.insert71.fca.2.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert71, 2
  %.fca.7.0.2.insert71.fca.3.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert71, 3
  %.fca.7.0.2.insert71.fca.4.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert71, 4
  %.fca.7.0.2.insert71.fca.5.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert71, 5
  %.fca.7.0.2.insert71.fca.6.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert71, 6
  %.fca.7.0.2.insert71.fca.7.0.0.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert71, 7, 0, 0
  %.fca.7.0.2.insert71.fca.7.0.1.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert71, 7, 0, 1
  %.fca.7.0.2.insert71.fca.7.0.2.extract = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert71, 7, 0, 2
  call void @free(ptr %.fca.7.0.2.insert71.fca.0.extract)
  %.fca.0.insert134 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } poison, ptr null, 0
  %.fca.1.insert137 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.0.insert134, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), 1
  %.fca.2.insert140 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.1.insert137, i32 20180515, 2
  %.fca.3.insert143 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.2.insert140, i8 1, 3
  %.fca.4.insert146 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.3.insert143, i8 28, 4
  %.fca.5.insert149 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.4.insert146, i8 2, 5
  %.fca.6.insert152 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.5.insert149, i8 0, 6
  %.fca.7.0.0.insert155 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.6.insert152, i64 1, 7, 0, 0
  %.fca.7.0.1.insert158 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.0.insert155, i64 0, 7, 0, 1
  %.fca.7.0.2.insert161 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.1.insert158, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), 7, 0, 2
  %.fca.0.extract72 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert161, 0
  %.fca.0.gep73 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 0
  store ptr %.fca.0.extract72, ptr %.fca.0.gep73, align 8, !tbaa !8
  %.fca.1.extract74 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert161, 1
  %.fca.1.gep75 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 1
  store i64 %.fca.1.extract74, ptr %.fca.1.gep75, align 8, !tbaa !8
  %.fca.2.extract76 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert161, 2
  %.fca.2.gep77 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 2
  store i32 %.fca.2.extract76, ptr %.fca.2.gep77, align 8, !tbaa !8
  %.fca.3.extract78 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert161, 3
  %.fca.3.gep79 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 3
  store i8 %.fca.3.extract78, ptr %.fca.3.gep79, align 4, !tbaa !8
  %.fca.4.extract80 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert161, 4
  %.fca.4.gep81 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 4
  store i8 %.fca.4.extract80, ptr %.fca.4.gep81, align 1, !tbaa !8
  %.fca.5.extract82 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert161, 5
  %.fca.5.gep83 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 5
  store i8 %.fca.5.extract82, ptr %.fca.5.gep83, align 2, !tbaa !8
  %.fca.6.extract84 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert161, 6
  %.fca.6.gep85 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 6
  store i8 %.fca.6.extract84, ptr %.fca.6.gep85, align 1, !tbaa !8
  %.fca.7.0.0.extract86 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert161, 7, 0, 0
  %.fca.7.0.0.gep87 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 0
  store i64 %.fca.7.0.0.extract86, ptr %.fca.7.0.0.gep87, align 8, !tbaa !8
  %.fca.7.0.1.extract88 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert161, 7, 0, 1
  %.fca.7.0.1.gep89 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 1
  store i64 %.fca.7.0.1.extract88, ptr %.fca.7.0.1.gep89, align 8, !tbaa !8
  %.fca.7.0.2.extract90 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.2.insert161, 7, 0, 2
  %.fca.7.0.2.gep91 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 2
  store i64 %.fca.7.0.2.extract90, ptr %.fca.7.0.2.gep91, align 8, !tbaa !8
  ret void
}
*** IR Dump After EarlyCSEPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, i64 1, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 1
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 2
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, i64 1, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = sext i32 %6 to i64
  %8 = icmp sgt i64 %7, 0
  %9 = select i1 %8, i64 %7, i64 0
  %10 = mul i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), %9
  %11 = call ptr @malloc(i64 %10)
  %12 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } { ptr undef, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), i32 20180515, i8 1, i8 28, i8 2, i8 0, [1 x [3 x i64]] [[3 x i64] [i64 1, i64 undef, i64 undef]] }, i64 %9, 7, 0, 1
  %13 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %12, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), 7, 0, 2
  %14 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %13, ptr %11, 0
  %.fca.1.extract173 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 1
  %.fca.2.extract175 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 2
  %.fca.3.extract177 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 3
  %.fca.4.extract179 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 4
  %.fca.5.extract181 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 5
  %.fca.6.extract183 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 6
  %.fca.7.0.0.extract185 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 7, 0, 0
  %.fca.0.insert193 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } poison, ptr %11, 0
  %.fca.1.insert196 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.0.insert193, i64 %.fca.1.extract173, 1
  %.fca.2.insert199 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.1.insert196, i32 %.fca.2.extract175, 2
  %.fca.3.insert202 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.2.insert199, i8 %.fca.3.extract177, 3
  %.fca.4.insert205 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.3.insert202, i8 %.fca.4.extract179, 4
  %.fca.5.insert208 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.4.insert205, i8 %.fca.5.extract181, 5
  %.fca.6.insert211 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.5.insert208, i8 %.fca.6.extract183, 6
  %.fca.7.0.0.insert214 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.6.insert211, i64 %.fca.7.0.0.extract185, 7, 0, 0
  %.fca.7.0.1.insert217 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.0.insert214, i64 %9, 7, 0, 1
  %.fca.7.0.2.insert220 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.1.insert217, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), 7, 0, 2
  store ptr %11, ptr %4, align 8, !tbaa !8
  store i64 %.fca.1.extract173, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 %.fca.2.extract175, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 %.fca.3.extract177, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 %.fca.4.extract179, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 %.fca.5.extract181, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 %.fca.6.extract183, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 %.fca.7.0.0.extract185, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %9, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @1, i32 1, ptr @_QFPomp_subroutine..omp_par, ptr %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.0.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } poison, ptr %.fca.0.load, 0
  %.fca.1.load = load i64, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.1.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.0.insert, i64 %.fca.1.load, 1
  %.fca.2.load = load i32, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.2.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.1.insert, i32 %.fca.2.load, 2
  %.fca.3.load = load i8, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.3.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.2.insert, i8 %.fca.3.load, 3
  %.fca.4.load = load i8, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.4.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.3.insert, i8 %.fca.4.load, 4
  %.fca.5.load = load i8, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.5.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.4.insert, i8 %.fca.5.load, 5
  %.fca.6.load = load i8, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.6.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.5.insert, i8 %.fca.6.load, 6
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.0.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.6.insert, i64 %.fca.7.0.0.load, 7, 0, 0
  %.fca.7.0.1.load = load i64, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.1.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.0.insert, i64 %.fca.7.0.1.load, 7, 0, 1
  %.fca.7.0.2.load = load i64, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %.fca.7.0.2.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.1.insert, i64 %.fca.7.0.2.load, 7, 0, 2
  %15 = sub i64 1, %.fca.7.0.0.load
  %16 = getelementptr double, ptr %.fca.0.load, i64 %15
  %17 = load double, ptr %16, align 8, !tbaa !4
  %18 = load i32, ptr %0, align 4, !tbaa !4
  %19 = sext i32 %18 to i64
  %20 = sub i64 %19, %.fca.7.0.0.load
  %21 = getelementptr double, ptr %.fca.0.load, i64 %20
  %22 = load double, ptr %21, align 8, !tbaa !4
  %23 = fadd contract double %17, %22
  store double %23, ptr %1, align 8, !tbaa !4
  %.fca.0.load43 = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.0.insert44 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } poison, ptr %.fca.0.load43, 0
  %.fca.1.load46 = load i64, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.1.insert47 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.0.insert44, i64 %.fca.1.load46, 1
  %.fca.2.load49 = load i32, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.2.insert50 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.1.insert47, i32 %.fca.2.load49, 2
  %.fca.3.load52 = load i8, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.3.insert53 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.2.insert50, i8 %.fca.3.load52, 3
  %.fca.4.load55 = load i8, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.4.insert56 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.3.insert53, i8 %.fca.4.load55, 4
  %.fca.5.load58 = load i8, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.5.insert59 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.4.insert56, i8 %.fca.5.load58, 5
  %.fca.6.load61 = load i8, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.6.insert62 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.5.insert59, i8 %.fca.6.load61, 6
  %.fca.7.0.0.load64 = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.0.insert65 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.6.insert62, i64 %.fca.7.0.0.load64, 7, 0, 0
  %.fca.7.0.1.load67 = load i64, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.1.insert68 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.0.insert65, i64 %.fca.7.0.1.load67, 7, 0, 1
  %.fca.7.0.2.load70 = load i64, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %.fca.7.0.2.insert71 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.1.insert68, i64 %.fca.7.0.2.load70, 7, 0, 2
  call void @free(ptr %.fca.0.load43)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After CallSiteSplittingPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, i64 1, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 1
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 2
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, i64 1, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = sext i32 %6 to i64
  %8 = icmp sgt i64 %7, 0
  %9 = select i1 %8, i64 %7, i64 0
  %10 = mul i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), %9
  %11 = call ptr @malloc(i64 %10)
  %12 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } { ptr undef, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), i32 20180515, i8 1, i8 28, i8 2, i8 0, [1 x [3 x i64]] [[3 x i64] [i64 1, i64 undef, i64 undef]] }, i64 %9, 7, 0, 1
  %13 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %12, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), 7, 0, 2
  %14 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %13, ptr %11, 0
  %.fca.1.extract173 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 1
  %.fca.2.extract175 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 2
  %.fca.3.extract177 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 3
  %.fca.4.extract179 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 4
  %.fca.5.extract181 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 5
  %.fca.6.extract183 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 6
  %.fca.7.0.0.extract185 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 7, 0, 0
  %.fca.0.insert193 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } poison, ptr %11, 0
  %.fca.1.insert196 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.0.insert193, i64 %.fca.1.extract173, 1
  %.fca.2.insert199 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.1.insert196, i32 %.fca.2.extract175, 2
  %.fca.3.insert202 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.2.insert199, i8 %.fca.3.extract177, 3
  %.fca.4.insert205 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.3.insert202, i8 %.fca.4.extract179, 4
  %.fca.5.insert208 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.4.insert205, i8 %.fca.5.extract181, 5
  %.fca.6.insert211 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.5.insert208, i8 %.fca.6.extract183, 6
  %.fca.7.0.0.insert214 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.6.insert211, i64 %.fca.7.0.0.extract185, 7, 0, 0
  %.fca.7.0.1.insert217 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.0.insert214, i64 %9, 7, 0, 1
  %.fca.7.0.2.insert220 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.1.insert217, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), 7, 0, 2
  store ptr %11, ptr %4, align 8, !tbaa !8
  store i64 %.fca.1.extract173, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 %.fca.2.extract175, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 %.fca.3.extract177, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 %.fca.4.extract179, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 %.fca.5.extract181, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 %.fca.6.extract183, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 %.fca.7.0.0.extract185, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %9, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @1, i32 1, ptr @_QFPomp_subroutine..omp_par, ptr %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.0.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } poison, ptr %.fca.0.load, 0
  %.fca.1.load = load i64, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.1.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.0.insert, i64 %.fca.1.load, 1
  %.fca.2.load = load i32, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.2.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.1.insert, i32 %.fca.2.load, 2
  %.fca.3.load = load i8, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.3.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.2.insert, i8 %.fca.3.load, 3
  %.fca.4.load = load i8, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.4.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.3.insert, i8 %.fca.4.load, 4
  %.fca.5.load = load i8, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.5.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.4.insert, i8 %.fca.5.load, 5
  %.fca.6.load = load i8, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.6.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.5.insert, i8 %.fca.6.load, 6
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.0.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.6.insert, i64 %.fca.7.0.0.load, 7, 0, 0
  %.fca.7.0.1.load = load i64, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.1.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.0.insert, i64 %.fca.7.0.1.load, 7, 0, 1
  %.fca.7.0.2.load = load i64, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %.fca.7.0.2.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.1.insert, i64 %.fca.7.0.2.load, 7, 0, 2
  %15 = sub i64 1, %.fca.7.0.0.load
  %16 = getelementptr double, ptr %.fca.0.load, i64 %15
  %17 = load double, ptr %16, align 8, !tbaa !4
  %18 = load i32, ptr %0, align 4, !tbaa !4
  %19 = sext i32 %18 to i64
  %20 = sub i64 %19, %.fca.7.0.0.load
  %21 = getelementptr double, ptr %.fca.0.load, i64 %20
  %22 = load double, ptr %21, align 8, !tbaa !4
  %23 = fadd contract double %17, %22
  store double %23, ptr %1, align 8, !tbaa !4
  %.fca.0.load43 = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.0.insert44 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } poison, ptr %.fca.0.load43, 0
  %.fca.1.load46 = load i64, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.1.insert47 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.0.insert44, i64 %.fca.1.load46, 1
  %.fca.2.load49 = load i32, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.2.insert50 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.1.insert47, i32 %.fca.2.load49, 2
  %.fca.3.load52 = load i8, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.3.insert53 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.2.insert50, i8 %.fca.3.load52, 3
  %.fca.4.load55 = load i8, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.4.insert56 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.3.insert53, i8 %.fca.4.load55, 4
  %.fca.5.load58 = load i8, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.5.insert59 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.4.insert56, i8 %.fca.5.load58, 5
  %.fca.6.load61 = load i8, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.6.insert62 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.5.insert59, i8 %.fca.6.load61, 6
  %.fca.7.0.0.load64 = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.0.insert65 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.6.insert62, i64 %.fca.7.0.0.load64, 7, 0, 0
  %.fca.7.0.1.load67 = load i64, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.1.insert68 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.0.insert65, i64 %.fca.7.0.1.load67, 7, 0, 1
  %.fca.7.0.2.load70 = load i64, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %.fca.7.0.2.insert71 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.1.insert68, i64 %.fca.7.0.2.load70, 7, 0, 2
  call void @free(ptr %.fca.0.load43)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After LowerExpectIntrinsicPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %gep_ = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 0
  %loadgep_ = load ptr, ptr %gep_, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %tid.addr.local = alloca i32, align 4
  %1 = load i32, ptr %tid.addr, align 4
  store i32 %1, ptr %tid.addr.local, align 4
  %tid = load i32, ptr %tid.addr.local, align 4
  br label %omp.par.region

omp.par.region:                                   ; preds = %omp.par.entry
  br label %omp.par.region1

omp.par.region1:                                  ; preds = %omp.par.region
  %2 = alloca i32, i64 1, align 4
  %3 = alloca i32, i64 1, align 4
  %4 = alloca i32, i64 1, align 4
  %5 = alloca i32, i64 1, align 4
  %6 = alloca i32, i64 1, align 4
  %7 = alloca i32, i64 1, align 4
  %8 = call i32 @omp_get_thread_num()
  store i32 %8, ptr %3, align 4, !tbaa !4
  %9 = call i32 @omp_get_num_threads()
  store i32 %9, ptr %4, align 4, !tbaa !4
  %10 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %11 = load i32, ptr %4, align 4, !tbaa !4
  %12 = sdiv i32 %10, %11
  store i32 %12, ptr %7, align 4, !tbaa !4
  %13 = load i32, ptr %3, align 4, !tbaa !4
  %14 = load i32, ptr %7, align 4, !tbaa !4
  %15 = mul i32 %13, %14
  %16 = add i32 %15, 1
  store i32 %16, ptr %5, align 4, !tbaa !4
  %17 = load i32, ptr %3, align 4, !tbaa !4
  %18 = load i32, ptr %4, align 4, !tbaa !4
  %19 = sub i32 %18, 1
  %20 = icmp eq i32 %17, %19
  br i1 %20, label %omp.par.region2, label %omp.par.region3

omp.par.region3:                                  ; preds = %omp.par.region1
  %21 = load i32, ptr %5, align 4, !tbaa !4
  %22 = load i32, ptr %7, align 4, !tbaa !4
  %23 = add i32 %21, %22
  store i32 %23, ptr %6, align 4, !tbaa !4
  br label %omp.par.region4

omp.par.region4:                                  ; preds = %omp.par.region2, %omp.par.region3
  %24 = load i32, ptr %5, align 4, !tbaa !4
  %25 = sext i32 %24 to i64
  %26 = load i32, ptr %6, align 4, !tbaa !4
  %27 = sext i32 %26 to i64
  %28 = trunc i64 %25 to i32
  %29 = sub i64 %27, %25
  %30 = add i64 %29, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.region4
  %31 = phi i32 [ %66, %omp.par.region6 ], [ %28, %omp.par.region4 ]
  %32 = phi i64 [ %67, %omp.par.region6 ], [ %30, %omp.par.region4 ]
  %33 = icmp sgt i64 %32, 0
  br i1 %33, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  store i32 %31, ptr %2, align 4, !tbaa !4
  br label %omp.region.cont

omp.region.cont:                                  ; preds = %omp.par.region7
  br label %omp.par.pre_finalize

omp.par.pre_finalize:                             ; preds = %omp.region.cont
  br label %omp.par.outlined.exit.exitStub

omp.par.region6:                                  ; preds = %omp.par.region5
  store i32 %31, ptr %2, align 4, !tbaa !4
  %34 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %35 = sitofp i32 %34 to float
  %36 = fdiv contract float 1.000000e+00, %35
  %37 = fpext float %36 to double
  %38 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %38, ptr %loadgep_4, align 8, !tbaa !8
  %39 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 0
  %40 = load i64, ptr %39, align 8, !tbaa !8
  %41 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 1
  %42 = load i64, ptr %41, align 8, !tbaa !8
  %43 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 2
  %44 = load i64, ptr %43, align 8, !tbaa !8
  %45 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 0
  %46 = load ptr, ptr %45, align 8, !tbaa !8
  %47 = load i32, ptr %2, align 4, !tbaa !4
  %48 = sext i32 %47 to i64
  %49 = sub i64 %48, %40
  %50 = getelementptr double, ptr %46, i64 %49
  store double %37, ptr %50, align 8, !tbaa !4
  %51 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %51, ptr %loadgep_6, align 8, !tbaa !8
  %52 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 0
  %53 = load i64, ptr %52, align 8, !tbaa !8
  %54 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 1
  %55 = load i64, ptr %54, align 8, !tbaa !8
  %56 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 2
  %57 = load i64, ptr %56, align 8, !tbaa !8
  %58 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 0
  %59 = load ptr, ptr %58, align 8, !tbaa !8
  %60 = load i32, ptr %2, align 4, !tbaa !4
  %61 = sext i32 %60 to i64
  %62 = sub i64 %61, %53
  %63 = getelementptr double, ptr %59, i64 %62
  %64 = load double, ptr %63, align 8, !tbaa !4
  store double %64, ptr %loadgep_8, align 8, !tbaa !4
  %65 = load i32, ptr %2, align 4, !tbaa !4
  %66 = add i32 %65, 1
  %67 = sub i64 %32, 1
  br label %omp.par.region5

omp.par.region2:                                  ; preds = %omp.par.region1
  %68 = load i32, ptr %loadgep_, align 4, !tbaa !4
  store i32 %68, ptr %6, align 4, !tbaa !4
  br label %omp.par.region4

omp.par.outlined.exit.exitStub:                   ; preds = %omp.par.pre_finalize
  ret void
}
*** IR Dump After SimplifyCFGPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %gep_ = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 0
  %loadgep_ = load ptr, ptr %gep_, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %tid.addr.local = alloca i32, align 4
  %1 = load i32, ptr %tid.addr, align 4
  store i32 %1, ptr %tid.addr.local, align 4
  %tid = load i32, ptr %tid.addr.local, align 4
  %2 = alloca i32, i64 1, align 4
  %3 = alloca i32, i64 1, align 4
  %4 = alloca i32, i64 1, align 4
  %5 = alloca i32, i64 1, align 4
  %6 = alloca i32, i64 1, align 4
  %7 = alloca i32, i64 1, align 4
  %8 = call i32 @omp_get_thread_num()
  store i32 %8, ptr %3, align 4, !tbaa !4
  %9 = call i32 @omp_get_num_threads()
  store i32 %9, ptr %4, align 4, !tbaa !4
  %10 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %11 = load i32, ptr %4, align 4, !tbaa !4
  %12 = sdiv i32 %10, %11
  store i32 %12, ptr %7, align 4, !tbaa !4
  %13 = load i32, ptr %3, align 4, !tbaa !4
  %14 = load i32, ptr %7, align 4, !tbaa !4
  %15 = mul i32 %13, %14
  %16 = add i32 %15, 1
  store i32 %16, ptr %5, align 4, !tbaa !4
  %17 = load i32, ptr %3, align 4, !tbaa !4
  %18 = load i32, ptr %4, align 4, !tbaa !4
  %19 = sub i32 %18, 1
  %20 = icmp eq i32 %17, %19
  br i1 %20, label %omp.par.region2, label %omp.par.region3

omp.par.region3:                                  ; preds = %omp.par.entry
  %21 = load i32, ptr %5, align 4, !tbaa !4
  %22 = load i32, ptr %7, align 4, !tbaa !4
  %23 = add i32 %21, %22
  store i32 %23, ptr %6, align 4, !tbaa !4
  br label %omp.par.region4

omp.par.region4:                                  ; preds = %omp.par.region2, %omp.par.region3
  %24 = load i32, ptr %5, align 4, !tbaa !4
  %25 = sext i32 %24 to i64
  %26 = load i32, ptr %6, align 4, !tbaa !4
  %27 = sext i32 %26 to i64
  %28 = trunc i64 %25 to i32
  %29 = sub i64 %27, %25
  %30 = add i64 %29, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.region4
  %31 = phi i32 [ %66, %omp.par.region6 ], [ %28, %omp.par.region4 ]
  %32 = phi i64 [ %67, %omp.par.region6 ], [ %30, %omp.par.region4 ]
  %33 = icmp sgt i64 %32, 0
  br i1 %33, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  store i32 %31, ptr %2, align 4, !tbaa !4
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  store i32 %31, ptr %2, align 4, !tbaa !4
  %34 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %35 = sitofp i32 %34 to float
  %36 = fdiv contract float 1.000000e+00, %35
  %37 = fpext float %36 to double
  %38 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %38, ptr %loadgep_4, align 8, !tbaa !8
  %39 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 0
  %40 = load i64, ptr %39, align 8, !tbaa !8
  %41 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 1
  %42 = load i64, ptr %41, align 8, !tbaa !8
  %43 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 2
  %44 = load i64, ptr %43, align 8, !tbaa !8
  %45 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 0
  %46 = load ptr, ptr %45, align 8, !tbaa !8
  %47 = load i32, ptr %2, align 4, !tbaa !4
  %48 = sext i32 %47 to i64
  %49 = sub i64 %48, %40
  %50 = getelementptr double, ptr %46, i64 %49
  store double %37, ptr %50, align 8, !tbaa !4
  %51 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %51, ptr %loadgep_6, align 8, !tbaa !8
  %52 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 0
  %53 = load i64, ptr %52, align 8, !tbaa !8
  %54 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 1
  %55 = load i64, ptr %54, align 8, !tbaa !8
  %56 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 2
  %57 = load i64, ptr %56, align 8, !tbaa !8
  %58 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 0
  %59 = load ptr, ptr %58, align 8, !tbaa !8
  %60 = load i32, ptr %2, align 4, !tbaa !4
  %61 = sext i32 %60 to i64
  %62 = sub i64 %61, %53
  %63 = getelementptr double, ptr %59, i64 %62
  %64 = load double, ptr %63, align 8, !tbaa !4
  store double %64, ptr %loadgep_8, align 8, !tbaa !4
  %65 = load i32, ptr %2, align 4, !tbaa !4
  %66 = add i32 %65, 1
  %67 = sub i64 %32, 1
  br label %omp.par.region5

omp.par.region2:                                  ; preds = %omp.par.entry
  %68 = load i32, ptr %loadgep_, align 4, !tbaa !4
  store i32 %68, ptr %6, align 4, !tbaa !4
  br label %omp.par.region4
}
*** IR Dump After SROAPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %gep_ = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 0
  %loadgep_ = load ptr, ptr %gep_, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = load i32, ptr %tid.addr, align 4
  %2 = call i32 @omp_get_thread_num()
  %3 = call i32 @omp_get_num_threads()
  %4 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %5 = sdiv i32 %4, %3
  %6 = mul i32 %2, %5
  %7 = add i32 %6, 1
  %8 = sub i32 %3, 1
  %9 = icmp eq i32 %2, %8
  br i1 %9, label %omp.par.region2, label %omp.par.region3

omp.par.region3:                                  ; preds = %omp.par.entry
  %10 = add i32 %7, %5
  br label %omp.par.region4

omp.par.region4:                                  ; preds = %omp.par.region2, %omp.par.region3
  %.0 = phi i32 [ %50, %omp.par.region2 ], [ %10, %omp.par.region3 ]
  %11 = sext i32 %7 to i64
  %12 = sext i32 %.0 to i64
  %13 = trunc i64 %11 to i32
  %14 = sub i64 %12, %11
  %15 = add i64 %14, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.region4
  %16 = phi i32 [ %48, %omp.par.region6 ], [ %13, %omp.par.region4 ]
  %17 = phi i64 [ %49, %omp.par.region6 ], [ %15, %omp.par.region4 ]
  %18 = icmp sgt i64 %17, 0
  br i1 %18, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %19 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %20 = sitofp i32 %19 to float
  %21 = fdiv contract float 1.000000e+00, %20
  %22 = fpext float %21 to double
  %23 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %23, ptr %loadgep_4, align 8, !tbaa !8
  %24 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 0
  %25 = load i64, ptr %24, align 8, !tbaa !8
  %26 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 1
  %27 = load i64, ptr %26, align 8, !tbaa !8
  %28 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 2
  %29 = load i64, ptr %28, align 8, !tbaa !8
  %30 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8, !tbaa !8
  %32 = sext i32 %16 to i64
  %33 = sub i64 %32, %25
  %34 = getelementptr double, ptr %31, i64 %33
  store double %22, ptr %34, align 8, !tbaa !4
  %35 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %35, ptr %loadgep_6, align 8, !tbaa !8
  %36 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 0
  %37 = load i64, ptr %36, align 8, !tbaa !8
  %38 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 1
  %39 = load i64, ptr %38, align 8, !tbaa !8
  %40 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 2
  %41 = load i64, ptr %40, align 8, !tbaa !8
  %42 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 0
  %43 = load ptr, ptr %42, align 8, !tbaa !8
  %44 = sext i32 %16 to i64
  %45 = sub i64 %44, %37
  %46 = getelementptr double, ptr %43, i64 %45
  %47 = load double, ptr %46, align 8, !tbaa !4
  store double %47, ptr %loadgep_8, align 8, !tbaa !4
  %48 = add i32 %16, 1
  %49 = sub i64 %17, 1
  br label %omp.par.region5

omp.par.region2:                                  ; preds = %omp.par.entry
  %50 = load i32, ptr %loadgep_, align 4, !tbaa !4
  br label %omp.par.region4
}
*** IR Dump After EarlyCSEPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = sub i32 %2, 1
  %8 = icmp eq i32 %1, %7
  br i1 %8, label %omp.par.region2, label %omp.par.region3

omp.par.region3:                                  ; preds = %omp.par.entry
  %9 = add i32 %6, %4
  br label %omp.par.region4

omp.par.region4:                                  ; preds = %omp.par.region2, %omp.par.region3
  %.0 = phi i32 [ %3, %omp.par.region2 ], [ %9, %omp.par.region3 ]
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub i64 %11, %10
  %13 = add i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.region4
  %14 = phi i32 [ %39, %omp.par.region6 ], [ %6, %omp.par.region4 ]
  %15 = phi i64 [ %40, %omp.par.region6 ], [ %13, %omp.par.region4 ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %21 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %21, ptr %loadgep_4, align 8, !tbaa !8
  %22 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 0
  %23 = load i64, ptr %22, align 8, !tbaa !8
  %24 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 1
  %25 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 2
  %26 = load ptr, ptr %loadgep_4, align 8, !tbaa !8
  %27 = sext i32 %14 to i64
  %28 = sub i64 %27, %23
  %29 = getelementptr double, ptr %26, i64 %28
  store double %20, ptr %29, align 8, !tbaa !4
  %30 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %30, ptr %loadgep_6, align 8, !tbaa !8
  %31 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 0
  %32 = load i64, ptr %31, align 8, !tbaa !8
  %33 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 1
  %34 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 2
  %35 = load ptr, ptr %loadgep_6, align 8, !tbaa !8
  %36 = sub i64 %27, %32
  %37 = getelementptr double, ptr %35, i64 %36
  %38 = load double, ptr %37, align 8, !tbaa !4
  store double %38, ptr %loadgep_8, align 8, !tbaa !4
  %39 = add i32 %14, 1
  %40 = sub i64 %15, 1
  br label %omp.par.region5

omp.par.region2:                                  ; preds = %omp.par.entry
  br label %omp.par.region4
}
*** IR Dump After CallSiteSplittingPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = sub i32 %2, 1
  %8 = icmp eq i32 %1, %7
  br i1 %8, label %omp.par.region2, label %omp.par.region3

omp.par.region3:                                  ; preds = %omp.par.entry
  %9 = add i32 %6, %4
  br label %omp.par.region4

omp.par.region4:                                  ; preds = %omp.par.region2, %omp.par.region3
  %.0 = phi i32 [ %3, %omp.par.region2 ], [ %9, %omp.par.region3 ]
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub i64 %11, %10
  %13 = add i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.region4
  %14 = phi i32 [ %39, %omp.par.region6 ], [ %6, %omp.par.region4 ]
  %15 = phi i64 [ %40, %omp.par.region6 ], [ %13, %omp.par.region4 ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %21 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %21, ptr %loadgep_4, align 8, !tbaa !8
  %22 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 0
  %23 = load i64, ptr %22, align 8, !tbaa !8
  %24 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 1
  %25 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 2
  %26 = load ptr, ptr %loadgep_4, align 8, !tbaa !8
  %27 = sext i32 %14 to i64
  %28 = sub i64 %27, %23
  %29 = getelementptr double, ptr %26, i64 %28
  store double %20, ptr %29, align 8, !tbaa !4
  %30 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %30, ptr %loadgep_6, align 8, !tbaa !8
  %31 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 0
  %32 = load i64, ptr %31, align 8, !tbaa !8
  %33 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 1
  %34 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 2
  %35 = load ptr, ptr %loadgep_6, align 8, !tbaa !8
  %36 = sub i64 %27, %32
  %37 = getelementptr double, ptr %35, i64 %36
  %38 = load double, ptr %37, align 8, !tbaa !4
  store double %38, ptr %loadgep_8, align 8, !tbaa !4
  %39 = add i32 %14, 1
  %40 = sub i64 %15, 1
  br label %omp.par.region5

omp.par.region2:                                  ; preds = %omp.par.entry
  br label %omp.par.region4
}
*** IR Dump After OpenMPOptPass on [module] ***
; ModuleID = 'FIRModule'
source_filename = "FIRModule"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.ident_t = type { i32, i32, i32, i32, ptr }

@_QMomp_libEComp_allocator_handle_kind = external constant i32
@_QMomp_libEComp_alloctrait_key_kind = external constant i32
@_QMomp_libEComp_alloctrait_val_kind = external constant i32
@_QMomp_libEComp_allow_completion_event = external constant i32
@_QMomp_libEComp_atk_access = external constant i32
@_QMomp_libEComp_atk_alignment = external constant i32
@_QMomp_libEComp_atk_fallback = external constant i32
@_QMomp_libEComp_atk_fb_data = external constant i32
@_QMomp_libEComp_atk_partition = external constant i32
@_QMomp_libEComp_atk_pinned = external constant i32
@_QMomp_libEComp_atk_pool_size = external constant i32
@_QMomp_libEComp_atk_sync_hint = external constant i32
@_QMomp_libEComp_atv_abort_fb = external constant i32
@_QMomp_libEComp_atv_all = external constant i32
@_QMomp_libEComp_atv_allocator_fb = external constant i32
@_QMomp_libEComp_atv_blocked = external constant i32
@_QMomp_libEComp_atv_cgroup = external constant i32
@_QMomp_libEComp_atv_contended = external constant i32
@_QMomp_libEComp_atv_default = external constant i32
@_QMomp_libEComp_atv_default_mem_fb = external constant i32
@_QMomp_libEComp_atv_environment = external constant i32
@_QMomp_libEComp_atv_false = external constant i32
@_QMomp_libEComp_atv_interleaved = external constant i32
@_QMomp_libEComp_atv_nearest = external constant i32
@_QMomp_libEComp_atv_null_fb = external constant i32
@_QMomp_libEComp_atv_private = external constant i32
@_QMomp_libEComp_atv_pteam = external constant i32
@_QMomp_libEComp_atv_sequential = external constant i32
@_QMomp_libEComp_atv_thread = external constant i32
@_QMomp_libEComp_atv_true = external constant i32
@_QMomp_libEComp_atv_uncontended = external constant i32
@_QMomp_libEComp_cgroup_mem_alloc = external constant i32
@_QMomp_libEComp_const_mem_alloc = external constant i32
@_QMomp_libEComp_const_mem_space = external constant i32
@_QMomp_libEComp_default_mem_alloc = external constant i32
@_QMomp_libEComp_default_mem_space = external constant i32
@_QMomp_libEComp_depend_kind = external constant i32
@_QMomp_libEComp_event_handle_kind = external constant i32
@_QMomp_libEComp_high_bw_mem_alloc = external constant i32
@_QMomp_libEComp_high_bw_mem_space = external constant i32
@_QMomp_libEComp_integer_kind = external constant i32
@_QMomp_libEComp_large_cap_mem_alloc = external constant i32
@_QMomp_libEComp_large_cap_mem_space = external constant i32
@_QMomp_libEComp_lock_hint_contended = external constant i32
@_QMomp_libEComp_lock_hint_kind = external constant i32
@_QMomp_libEComp_lock_hint_none = external constant i32
@_QMomp_libEComp_lock_hint_nonspeculative = external constant i32
@_QMomp_libEComp_lock_hint_speculative = external constant i32
@_QMomp_libEComp_lock_hint_uncontended = external constant i32
@_QMomp_libEComp_lock_kind = external constant i32
@_QMomp_libEComp_logical_kind = external constant i32
@_QMomp_libEComp_low_lat_mem_alloc = external constant i32
@_QMomp_libEComp_low_lat_mem_space = external constant i32
@_QMomp_libEComp_memspace_handle_kind = external constant i32
@_QMomp_libEComp_nest_lock_kind = external constant i32
@_QMomp_libEComp_null_allocator = external constant i32
@_QMomp_libEComp_pause_hard = external constant i32
@_QMomp_libEComp_pause_resource_kind = external constant i32
@_QMomp_libEComp_pause_soft = external constant i32
@_QMomp_libEComp_proc_bind_close = external constant i32
@_QMomp_libEComp_proc_bind_false = external constant i32
@_QMomp_libEComp_proc_bind_kind = external constant i32
@_QMomp_libEComp_proc_bind_master = external constant i32
@_QMomp_libEComp_proc_bind_spread = external constant i32
@_QMomp_libEComp_proc_bind_true = external constant i32
@_QMomp_libEComp_pteam_mem_alloc = external constant i32
@_QMomp_libEComp_sched_auto = external constant i32
@_QMomp_libEComp_sched_dynamic = external constant i32
@_QMomp_libEComp_sched_guided = external constant i32
@_QMomp_libEComp_sched_kind = external constant i32
@_QMomp_libEComp_sched_static = external constant i32
@_QMomp_libEComp_sync_hint_contended = external constant i32
@_QMomp_libEComp_sync_hint_kind = external constant i32
@_QMomp_libEComp_sync_hint_none = external constant i32
@_QMomp_libEComp_sync_hint_nonspeculative = external constant i32
@_QMomp_libEComp_sync_hint_speculative = external constant i32
@_QMomp_libEComp_sync_hint_uncontended = external constant i32
@_QMomp_libEComp_task_fulfill_event = external constant i32
@_QMomp_libEComp_thread_mem_alloc = external constant i32
@_QMomp_libECopenmp_version = external constant i32
@_QQcl.28612C69372C612C6531332E36653229 = internal constant [16 x i8] c"(a,i7,a,e13.6e2)"
@_QQcl.21557d42704c5c1f18a68415065290ee = internal constant [50 x i8] c"/g/g92/rydahl1/flangtests/src/parallel_region.f90\00"
@_QQcl.54686520726573756C74206F6620286172722831292B61727228 = internal constant [26 x i8] c"The result of (arr(1)+arr("
@_QQcl.2920697320 = internal constant [5 x i8] c") is "
@_QQEnvironmentDefaults = constant ptr null
@0 = private unnamed_addr constant [23 x i8] c";unknown;unknown;0;0;;\00", align 1
@1 = private unnamed_addr constant %struct.ident_t { i32 0, i32 2, i32 0, i32 22, ptr @0 }, align 8

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite)
declare noalias noundef ptr @malloc(i64 noundef) #0

; Function Attrs: mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite)
declare void @free(ptr allocptr nocapture noundef) #1

define void @_QQmain() {
  %1 = alloca i32, i64 1, align 4
  %2 = alloca double, i64 1, align 8
  store i32 1048576, ptr %1, align 4, !tbaa !4
  call void @_QFPomp_subroutine(ptr %1, ptr %2)
  %3 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %4 = call i1 @_FortranAioOutputAscii(ptr %3, ptr @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %5 = load i32, ptr %1, align 4, !tbaa !4
  %6 = call i1 @_FortranAioOutputInteger32(ptr %3, i32 %5)
  %7 = call i1 @_FortranAioOutputAscii(ptr %3, ptr @_QQcl.2920697320, i64 5)
  %8 = load double, ptr %2, align 8, !tbaa !4
  %9 = call i1 @_FortranAioOutputReal64(ptr %3, double %8)
  %10 = call i32 @_FortranAioEndIoStatement(ptr %3)
  ret void
}

define void @_QFPomp_subroutine(ptr %0, ptr %1) {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, i64 1, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 1
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 2
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, i64 1, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = sext i32 %6 to i64
  %8 = icmp sgt i64 %7, 0
  %9 = select i1 %8, i64 %7, i64 0
  %10 = mul i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), %9
  %11 = call ptr @malloc(i64 %10)
  %12 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } { ptr undef, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), i32 20180515, i8 1, i8 28, i8 2, i8 0, [1 x [3 x i64]] [[3 x i64] [i64 1, i64 undef, i64 undef]] }, i64 %9, 7, 0, 1
  %13 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %12, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), 7, 0, 2
  %14 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %13, ptr %11, 0
  %.fca.1.extract173 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 1
  %.fca.2.extract175 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 2
  %.fca.3.extract177 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 3
  %.fca.4.extract179 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 4
  %.fca.5.extract181 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 5
  %.fca.6.extract183 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 6
  %.fca.7.0.0.extract185 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 7, 0, 0
  %.fca.0.insert193 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } poison, ptr %11, 0
  %.fca.1.insert196 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.0.insert193, i64 %.fca.1.extract173, 1
  %.fca.2.insert199 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.1.insert196, i32 %.fca.2.extract175, 2
  %.fca.3.insert202 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.2.insert199, i8 %.fca.3.extract177, 3
  %.fca.4.insert205 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.3.insert202, i8 %.fca.4.extract179, 4
  %.fca.5.insert208 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.4.insert205, i8 %.fca.5.extract181, 5
  %.fca.6.insert211 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.5.insert208, i8 %.fca.6.extract183, 6
  %.fca.7.0.0.insert214 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.6.insert211, i64 %.fca.7.0.0.extract185, 7, 0, 0
  %.fca.7.0.1.insert217 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.0.insert214, i64 %9, 7, 0, 1
  %.fca.7.0.2.insert220 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.1.insert217, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), 7, 0, 2
  store ptr %11, ptr %4, align 8, !tbaa !8
  store i64 %.fca.1.extract173, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 %.fca.2.extract175, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 %.fca.3.extract177, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 %.fca.4.extract179, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 %.fca.5.extract181, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 %.fca.6.extract183, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 %.fca.7.0.0.extract185, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %9, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @1, i32 1, ptr @_QFPomp_subroutine..omp_par, ptr %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.0.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } poison, ptr %.fca.0.load, 0
  %.fca.1.load = load i64, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.1.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.0.insert, i64 %.fca.1.load, 1
  %.fca.2.load = load i32, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.2.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.1.insert, i32 %.fca.2.load, 2
  %.fca.3.load = load i8, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.3.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.2.insert, i8 %.fca.3.load, 3
  %.fca.4.load = load i8, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.4.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.3.insert, i8 %.fca.4.load, 4
  %.fca.5.load = load i8, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.5.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.4.insert, i8 %.fca.5.load, 5
  %.fca.6.load = load i8, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.6.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.5.insert, i8 %.fca.6.load, 6
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.0.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.6.insert, i64 %.fca.7.0.0.load, 7, 0, 0
  %.fca.7.0.1.load = load i64, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.1.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.0.insert, i64 %.fca.7.0.1.load, 7, 0, 1
  %.fca.7.0.2.load = load i64, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %.fca.7.0.2.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.1.insert, i64 %.fca.7.0.2.load, 7, 0, 2
  %15 = sub i64 1, %.fca.7.0.0.load
  %16 = getelementptr double, ptr %.fca.0.load, i64 %15
  %17 = load double, ptr %16, align 8, !tbaa !4
  %18 = load i32, ptr %0, align 4, !tbaa !4
  %19 = sext i32 %18 to i64
  %20 = sub i64 %19, %.fca.7.0.0.load
  %21 = getelementptr double, ptr %.fca.0.load, i64 %20
  %22 = load double, ptr %21, align 8, !tbaa !4
  %23 = fadd contract double %17, %22
  store double %23, ptr %1, align 8, !tbaa !4
  %.fca.0.load43 = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.0.insert44 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } poison, ptr %.fca.0.load43, 0
  %.fca.1.load46 = load i64, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.1.insert47 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.0.insert44, i64 %.fca.1.load46, 1
  %.fca.2.load49 = load i32, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.2.insert50 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.1.insert47, i32 %.fca.2.load49, 2
  %.fca.3.load52 = load i8, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.3.insert53 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.2.insert50, i8 %.fca.3.load52, 3
  %.fca.4.load55 = load i8, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.4.insert56 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.3.insert53, i8 %.fca.4.load55, 4
  %.fca.5.load58 = load i8, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.5.insert59 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.4.insert56, i8 %.fca.5.load58, 5
  %.fca.6.load61 = load i8, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.6.insert62 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.5.insert59, i8 %.fca.6.load61, 6
  %.fca.7.0.0.load64 = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.0.insert65 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.6.insert62, i64 %.fca.7.0.0.load64, 7, 0, 0
  %.fca.7.0.1.load67 = load i64, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.1.insert68 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.0.insert65, i64 %.fca.7.0.1.load67, 7, 0, 1
  %.fca.7.0.2.load70 = load i64, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %.fca.7.0.2.insert71 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.1.insert68, i64 %.fca.7.0.2.load70, 7, 0, 2
  call void @free(ptr %.fca.0.load43)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}

; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = sub i32 %2, 1
  %8 = icmp eq i32 %1, %7
  br i1 %8, label %omp.par.region2, label %omp.par.region3

omp.par.region3:                                  ; preds = %omp.par.entry
  %9 = add i32 %6, %4
  br label %omp.par.region4

omp.par.region4:                                  ; preds = %omp.par.region2, %omp.par.region3
  %.0 = phi i32 [ %3, %omp.par.region2 ], [ %9, %omp.par.region3 ]
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub i64 %11, %10
  %13 = add i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.region4
  %14 = phi i32 [ %39, %omp.par.region6 ], [ %6, %omp.par.region4 ]
  %15 = phi i64 [ %40, %omp.par.region6 ], [ %13, %omp.par.region4 ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %21 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %21, ptr %loadgep_4, align 8, !tbaa !8
  %22 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 0
  %23 = load i64, ptr %22, align 8, !tbaa !8
  %24 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 1
  %25 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 2
  %26 = load ptr, ptr %loadgep_4, align 8, !tbaa !8
  %27 = sext i32 %14 to i64
  %28 = sub i64 %27, %23
  %29 = getelementptr double, ptr %26, i64 %28
  store double %20, ptr %29, align 8, !tbaa !4
  %30 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %30, ptr %loadgep_6, align 8, !tbaa !8
  %31 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 0
  %32 = load i64, ptr %31, align 8, !tbaa !8
  %33 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 1
  %34 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 2
  %35 = load ptr, ptr %loadgep_6, align 8, !tbaa !8
  %36 = sub i64 %27, %32
  %37 = getelementptr double, ptr %35, i64 %36
  %38 = load double, ptr %37, align 8, !tbaa !4
  store double %38, ptr %loadgep_8, align 8, !tbaa !4
  %39 = add i32 %14, 1
  %40 = sub i64 %15, 1
  br label %omp.par.region5

omp.par.region2:                                  ; preds = %omp.par.entry
  br label %omp.par.region4
}

declare ptr @_FortranAioBeginExternalFormattedOutput(ptr, i64, ptr, i32, ptr, i32)

declare zeroext i1 @_FortranAioOutputAscii(ptr, ptr, i64)

declare zeroext i1 @_FortranAioOutputInteger32(ptr, i32)

declare zeroext i1 @_FortranAioOutputReal64(ptr, double)

declare i32 @_FortranAioEndIoStatement(ptr)

; Function Attrs: nounwind
declare i32 @omp_get_thread_num() #3

; Function Attrs: nounwind
declare i32 @omp_get_num_threads() #3

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn
declare ptr @llvm.stacksave() #4

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn
declare void @llvm.stackrestore(ptr) #4

; Function Attrs: nounwind
declare i32 @__kmpc_global_thread_num(ptr) #3

; Function Attrs: nounwind
declare !callback !10 void @__kmpc_fork_call(ptr, i32, ptr, ...) #3

attributes #0 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #1 = { mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #2 = { norecurse nounwind }
attributes #3 = { nounwind }
attributes #4 = { mustprogress nocallback nofree nosync nounwind willreturn }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i32 7, !"openmp", i32 11}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{!5, !5, i64 0}
!5 = !{!"any data access", !6, i64 0}
!6 = !{!"any access", !7, i64 0}
!7 = !{!"Flang Type TBAA Root"}
!8 = !{!9, !9, i64 0}
!9 = !{!"descriptor member", !6, i64 0}
!10 = !{!11}
!11 = !{i64 2, i64 -1, i64 -1, i1 true}
*** IR Dump After IPSCCPPass on [module] ***
; ModuleID = 'FIRModule'
source_filename = "FIRModule"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.ident_t = type { i32, i32, i32, i32, ptr }

@_QMomp_libEComp_allocator_handle_kind = external constant i32
@_QMomp_libEComp_alloctrait_key_kind = external constant i32
@_QMomp_libEComp_alloctrait_val_kind = external constant i32
@_QMomp_libEComp_allow_completion_event = external constant i32
@_QMomp_libEComp_atk_access = external constant i32
@_QMomp_libEComp_atk_alignment = external constant i32
@_QMomp_libEComp_atk_fallback = external constant i32
@_QMomp_libEComp_atk_fb_data = external constant i32
@_QMomp_libEComp_atk_partition = external constant i32
@_QMomp_libEComp_atk_pinned = external constant i32
@_QMomp_libEComp_atk_pool_size = external constant i32
@_QMomp_libEComp_atk_sync_hint = external constant i32
@_QMomp_libEComp_atv_abort_fb = external constant i32
@_QMomp_libEComp_atv_all = external constant i32
@_QMomp_libEComp_atv_allocator_fb = external constant i32
@_QMomp_libEComp_atv_blocked = external constant i32
@_QMomp_libEComp_atv_cgroup = external constant i32
@_QMomp_libEComp_atv_contended = external constant i32
@_QMomp_libEComp_atv_default = external constant i32
@_QMomp_libEComp_atv_default_mem_fb = external constant i32
@_QMomp_libEComp_atv_environment = external constant i32
@_QMomp_libEComp_atv_false = external constant i32
@_QMomp_libEComp_atv_interleaved = external constant i32
@_QMomp_libEComp_atv_nearest = external constant i32
@_QMomp_libEComp_atv_null_fb = external constant i32
@_QMomp_libEComp_atv_private = external constant i32
@_QMomp_libEComp_atv_pteam = external constant i32
@_QMomp_libEComp_atv_sequential = external constant i32
@_QMomp_libEComp_atv_thread = external constant i32
@_QMomp_libEComp_atv_true = external constant i32
@_QMomp_libEComp_atv_uncontended = external constant i32
@_QMomp_libEComp_cgroup_mem_alloc = external constant i32
@_QMomp_libEComp_const_mem_alloc = external constant i32
@_QMomp_libEComp_const_mem_space = external constant i32
@_QMomp_libEComp_default_mem_alloc = external constant i32
@_QMomp_libEComp_default_mem_space = external constant i32
@_QMomp_libEComp_depend_kind = external constant i32
@_QMomp_libEComp_event_handle_kind = external constant i32
@_QMomp_libEComp_high_bw_mem_alloc = external constant i32
@_QMomp_libEComp_high_bw_mem_space = external constant i32
@_QMomp_libEComp_integer_kind = external constant i32
@_QMomp_libEComp_large_cap_mem_alloc = external constant i32
@_QMomp_libEComp_large_cap_mem_space = external constant i32
@_QMomp_libEComp_lock_hint_contended = external constant i32
@_QMomp_libEComp_lock_hint_kind = external constant i32
@_QMomp_libEComp_lock_hint_none = external constant i32
@_QMomp_libEComp_lock_hint_nonspeculative = external constant i32
@_QMomp_libEComp_lock_hint_speculative = external constant i32
@_QMomp_libEComp_lock_hint_uncontended = external constant i32
@_QMomp_libEComp_lock_kind = external constant i32
@_QMomp_libEComp_logical_kind = external constant i32
@_QMomp_libEComp_low_lat_mem_alloc = external constant i32
@_QMomp_libEComp_low_lat_mem_space = external constant i32
@_QMomp_libEComp_memspace_handle_kind = external constant i32
@_QMomp_libEComp_nest_lock_kind = external constant i32
@_QMomp_libEComp_null_allocator = external constant i32
@_QMomp_libEComp_pause_hard = external constant i32
@_QMomp_libEComp_pause_resource_kind = external constant i32
@_QMomp_libEComp_pause_soft = external constant i32
@_QMomp_libEComp_proc_bind_close = external constant i32
@_QMomp_libEComp_proc_bind_false = external constant i32
@_QMomp_libEComp_proc_bind_kind = external constant i32
@_QMomp_libEComp_proc_bind_master = external constant i32
@_QMomp_libEComp_proc_bind_spread = external constant i32
@_QMomp_libEComp_proc_bind_true = external constant i32
@_QMomp_libEComp_pteam_mem_alloc = external constant i32
@_QMomp_libEComp_sched_auto = external constant i32
@_QMomp_libEComp_sched_dynamic = external constant i32
@_QMomp_libEComp_sched_guided = external constant i32
@_QMomp_libEComp_sched_kind = external constant i32
@_QMomp_libEComp_sched_static = external constant i32
@_QMomp_libEComp_sync_hint_contended = external constant i32
@_QMomp_libEComp_sync_hint_kind = external constant i32
@_QMomp_libEComp_sync_hint_none = external constant i32
@_QMomp_libEComp_sync_hint_nonspeculative = external constant i32
@_QMomp_libEComp_sync_hint_speculative = external constant i32
@_QMomp_libEComp_sync_hint_uncontended = external constant i32
@_QMomp_libEComp_task_fulfill_event = external constant i32
@_QMomp_libEComp_thread_mem_alloc = external constant i32
@_QMomp_libECopenmp_version = external constant i32
@_QQcl.28612C69372C612C6531332E36653229 = internal constant [16 x i8] c"(a,i7,a,e13.6e2)"
@_QQcl.21557d42704c5c1f18a68415065290ee = internal constant [50 x i8] c"/g/g92/rydahl1/flangtests/src/parallel_region.f90\00"
@_QQcl.54686520726573756C74206F6620286172722831292B61727228 = internal constant [26 x i8] c"The result of (arr(1)+arr("
@_QQcl.2920697320 = internal constant [5 x i8] c") is "
@_QQEnvironmentDefaults = constant ptr null
@0 = private unnamed_addr constant [23 x i8] c";unknown;unknown;0;0;;\00", align 1
@1 = private unnamed_addr constant %struct.ident_t { i32 0, i32 2, i32 0, i32 22, ptr @0 }, align 8

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite)
declare noalias noundef ptr @malloc(i64 noundef) #0

; Function Attrs: mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite)
declare void @free(ptr allocptr nocapture noundef) #1

define void @_QQmain() {
  %1 = alloca i32, i64 1, align 4
  %2 = alloca double, i64 1, align 8
  store i32 1048576, ptr %1, align 4, !tbaa !4
  call void @_QFPomp_subroutine(ptr %1, ptr %2)
  %3 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %4 = call i1 @_FortranAioOutputAscii(ptr %3, ptr @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %5 = load i32, ptr %1, align 4, !tbaa !4
  %6 = call i1 @_FortranAioOutputInteger32(ptr %3, i32 %5)
  %7 = call i1 @_FortranAioOutputAscii(ptr %3, ptr @_QQcl.2920697320, i64 5)
  %8 = load double, ptr %2, align 8, !tbaa !4
  %9 = call i1 @_FortranAioOutputReal64(ptr %3, double %8)
  %10 = call i32 @_FortranAioEndIoStatement(ptr %3)
  ret void
}

define void @_QFPomp_subroutine(ptr %0, ptr %1) {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, i64 1, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 1
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 2
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, i64 1, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = sext i32 %6 to i64
  %8 = icmp sgt i64 %7, 0
  %9 = select i1 %8, i64 %7, i64 0
  %10 = mul i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), %9
  %11 = call ptr @malloc(i64 %10)
  %12 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } { ptr undef, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), i32 20180515, i8 1, i8 28, i8 2, i8 0, [1 x [3 x i64]] [[3 x i64] [i64 1, i64 undef, i64 undef]] }, i64 %9, 7, 0, 1
  %13 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %12, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), 7, 0, 2
  %14 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %13, ptr %11, 0
  %.fca.1.extract173 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 1
  %.fca.2.extract175 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 2
  %.fca.3.extract177 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 3
  %.fca.4.extract179 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 4
  %.fca.5.extract181 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 5
  %.fca.6.extract183 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 6
  %.fca.7.0.0.extract185 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 7, 0, 0
  %.fca.0.insert193 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } poison, ptr %11, 0
  %.fca.1.insert196 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.0.insert193, i64 %.fca.1.extract173, 1
  %.fca.2.insert199 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.1.insert196, i32 %.fca.2.extract175, 2
  %.fca.3.insert202 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.2.insert199, i8 %.fca.3.extract177, 3
  %.fca.4.insert205 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.3.insert202, i8 %.fca.4.extract179, 4
  %.fca.5.insert208 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.4.insert205, i8 %.fca.5.extract181, 5
  %.fca.6.insert211 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.5.insert208, i8 %.fca.6.extract183, 6
  %.fca.7.0.0.insert214 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.6.insert211, i64 %.fca.7.0.0.extract185, 7, 0, 0
  %.fca.7.0.1.insert217 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.0.insert214, i64 %9, 7, 0, 1
  %.fca.7.0.2.insert220 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.1.insert217, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), 7, 0, 2
  store ptr %11, ptr %4, align 8, !tbaa !8
  store i64 %.fca.1.extract173, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 %.fca.2.extract175, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 %.fca.3.extract177, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 %.fca.4.extract179, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 %.fca.5.extract181, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 %.fca.6.extract183, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 %.fca.7.0.0.extract185, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %9, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @1, i32 1, ptr @_QFPomp_subroutine..omp_par, ptr %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.0.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } poison, ptr %.fca.0.load, 0
  %.fca.1.load = load i64, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.1.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.0.insert, i64 %.fca.1.load, 1
  %.fca.2.load = load i32, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.2.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.1.insert, i32 %.fca.2.load, 2
  %.fca.3.load = load i8, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.3.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.2.insert, i8 %.fca.3.load, 3
  %.fca.4.load = load i8, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.4.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.3.insert, i8 %.fca.4.load, 4
  %.fca.5.load = load i8, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.5.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.4.insert, i8 %.fca.5.load, 5
  %.fca.6.load = load i8, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.6.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.5.insert, i8 %.fca.6.load, 6
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.0.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.6.insert, i64 %.fca.7.0.0.load, 7, 0, 0
  %.fca.7.0.1.load = load i64, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.1.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.0.insert, i64 %.fca.7.0.1.load, 7, 0, 1
  %.fca.7.0.2.load = load i64, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %.fca.7.0.2.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.1.insert, i64 %.fca.7.0.2.load, 7, 0, 2
  %15 = sub i64 1, %.fca.7.0.0.load
  %16 = getelementptr double, ptr %.fca.0.load, i64 %15
  %17 = load double, ptr %16, align 8, !tbaa !4
  %18 = load i32, ptr %0, align 4, !tbaa !4
  %19 = sext i32 %18 to i64
  %20 = sub i64 %19, %.fca.7.0.0.load
  %21 = getelementptr double, ptr %.fca.0.load, i64 %20
  %22 = load double, ptr %21, align 8, !tbaa !4
  %23 = fadd contract double %17, %22
  store double %23, ptr %1, align 8, !tbaa !4
  %.fca.0.load43 = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.0.insert44 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } poison, ptr %.fca.0.load43, 0
  %.fca.1.load46 = load i64, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.1.insert47 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.0.insert44, i64 %.fca.1.load46, 1
  %.fca.2.load49 = load i32, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.2.insert50 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.1.insert47, i32 %.fca.2.load49, 2
  %.fca.3.load52 = load i8, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.3.insert53 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.2.insert50, i8 %.fca.3.load52, 3
  %.fca.4.load55 = load i8, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.4.insert56 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.3.insert53, i8 %.fca.4.load55, 4
  %.fca.5.load58 = load i8, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.5.insert59 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.4.insert56, i8 %.fca.5.load58, 5
  %.fca.6.load61 = load i8, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.6.insert62 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.5.insert59, i8 %.fca.6.load61, 6
  %.fca.7.0.0.load64 = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.0.insert65 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.6.insert62, i64 %.fca.7.0.0.load64, 7, 0, 0
  %.fca.7.0.1.load67 = load i64, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.1.insert68 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.0.insert65, i64 %.fca.7.0.1.load67, 7, 0, 1
  %.fca.7.0.2.load70 = load i64, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %.fca.7.0.2.insert71 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.1.insert68, i64 %.fca.7.0.2.load70, 7, 0, 2
  call void @free(ptr %.fca.0.load43)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}

; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = sub i32 %2, 1
  %8 = icmp eq i32 %1, %7
  br i1 %8, label %omp.par.region2, label %omp.par.region3

omp.par.region3:                                  ; preds = %omp.par.entry
  %9 = add i32 %6, %4
  br label %omp.par.region4

omp.par.region4:                                  ; preds = %omp.par.region2, %omp.par.region3
  %.0 = phi i32 [ %3, %omp.par.region2 ], [ %9, %omp.par.region3 ]
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub nsw i64 %11, %10
  %13 = add nsw i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.region4
  %14 = phi i32 [ %39, %omp.par.region6 ], [ %6, %omp.par.region4 ]
  %15 = phi i64 [ %40, %omp.par.region6 ], [ %13, %omp.par.region4 ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %21 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %21, ptr %loadgep_4, align 8, !tbaa !8
  %22 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 0
  %23 = load i64, ptr %22, align 8, !tbaa !8
  %24 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 1
  %25 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 2
  %26 = load ptr, ptr %loadgep_4, align 8, !tbaa !8
  %27 = sext i32 %14 to i64
  %28 = sub i64 %27, %23
  %29 = getelementptr double, ptr %26, i64 %28
  store double %20, ptr %29, align 8, !tbaa !4
  %30 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %30, ptr %loadgep_6, align 8, !tbaa !8
  %31 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 0
  %32 = load i64, ptr %31, align 8, !tbaa !8
  %33 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 1
  %34 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 2
  %35 = load ptr, ptr %loadgep_6, align 8, !tbaa !8
  %36 = sub i64 %27, %32
  %37 = getelementptr double, ptr %35, i64 %36
  %38 = load double, ptr %37, align 8, !tbaa !4
  store double %38, ptr %loadgep_8, align 8, !tbaa !4
  %39 = add i32 %14, 1
  %40 = sub nuw nsw i64 %15, 1
  br label %omp.par.region5

omp.par.region2:                                  ; preds = %omp.par.entry
  br label %omp.par.region4
}

declare ptr @_FortranAioBeginExternalFormattedOutput(ptr, i64, ptr, i32, ptr, i32)

declare zeroext i1 @_FortranAioOutputAscii(ptr, ptr, i64)

declare zeroext i1 @_FortranAioOutputInteger32(ptr, i32)

declare zeroext i1 @_FortranAioOutputReal64(ptr, double)

declare i32 @_FortranAioEndIoStatement(ptr)

; Function Attrs: nounwind
declare i32 @omp_get_thread_num() #3

; Function Attrs: nounwind
declare i32 @omp_get_num_threads() #3

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn
declare ptr @llvm.stacksave() #4

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn
declare void @llvm.stackrestore(ptr) #4

; Function Attrs: nounwind
declare i32 @__kmpc_global_thread_num(ptr) #3

; Function Attrs: nounwind
declare !callback !10 void @__kmpc_fork_call(ptr, i32, ptr, ...) #3

attributes #0 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #1 = { mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #2 = { norecurse nounwind }
attributes #3 = { nounwind }
attributes #4 = { mustprogress nocallback nofree nosync nounwind willreturn }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i32 7, !"openmp", i32 11}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{!5, !5, i64 0}
!5 = !{!"any data access", !6, i64 0}
!6 = !{!"any access", !7, i64 0}
!7 = !{!"Flang Type TBAA Root"}
!8 = !{!9, !9, i64 0}
!9 = !{!"descriptor member", !6, i64 0}
!10 = !{!11}
!11 = !{i64 2, i64 -1, i64 -1, i1 true}
*** IR Dump After CalledValuePropagationPass on [module] ***
; ModuleID = 'FIRModule'
source_filename = "FIRModule"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.ident_t = type { i32, i32, i32, i32, ptr }

@_QMomp_libEComp_allocator_handle_kind = external constant i32
@_QMomp_libEComp_alloctrait_key_kind = external constant i32
@_QMomp_libEComp_alloctrait_val_kind = external constant i32
@_QMomp_libEComp_allow_completion_event = external constant i32
@_QMomp_libEComp_atk_access = external constant i32
@_QMomp_libEComp_atk_alignment = external constant i32
@_QMomp_libEComp_atk_fallback = external constant i32
@_QMomp_libEComp_atk_fb_data = external constant i32
@_QMomp_libEComp_atk_partition = external constant i32
@_QMomp_libEComp_atk_pinned = external constant i32
@_QMomp_libEComp_atk_pool_size = external constant i32
@_QMomp_libEComp_atk_sync_hint = external constant i32
@_QMomp_libEComp_atv_abort_fb = external constant i32
@_QMomp_libEComp_atv_all = external constant i32
@_QMomp_libEComp_atv_allocator_fb = external constant i32
@_QMomp_libEComp_atv_blocked = external constant i32
@_QMomp_libEComp_atv_cgroup = external constant i32
@_QMomp_libEComp_atv_contended = external constant i32
@_QMomp_libEComp_atv_default = external constant i32
@_QMomp_libEComp_atv_default_mem_fb = external constant i32
@_QMomp_libEComp_atv_environment = external constant i32
@_QMomp_libEComp_atv_false = external constant i32
@_QMomp_libEComp_atv_interleaved = external constant i32
@_QMomp_libEComp_atv_nearest = external constant i32
@_QMomp_libEComp_atv_null_fb = external constant i32
@_QMomp_libEComp_atv_private = external constant i32
@_QMomp_libEComp_atv_pteam = external constant i32
@_QMomp_libEComp_atv_sequential = external constant i32
@_QMomp_libEComp_atv_thread = external constant i32
@_QMomp_libEComp_atv_true = external constant i32
@_QMomp_libEComp_atv_uncontended = external constant i32
@_QMomp_libEComp_cgroup_mem_alloc = external constant i32
@_QMomp_libEComp_const_mem_alloc = external constant i32
@_QMomp_libEComp_const_mem_space = external constant i32
@_QMomp_libEComp_default_mem_alloc = external constant i32
@_QMomp_libEComp_default_mem_space = external constant i32
@_QMomp_libEComp_depend_kind = external constant i32
@_QMomp_libEComp_event_handle_kind = external constant i32
@_QMomp_libEComp_high_bw_mem_alloc = external constant i32
@_QMomp_libEComp_high_bw_mem_space = external constant i32
@_QMomp_libEComp_integer_kind = external constant i32
@_QMomp_libEComp_large_cap_mem_alloc = external constant i32
@_QMomp_libEComp_large_cap_mem_space = external constant i32
@_QMomp_libEComp_lock_hint_contended = external constant i32
@_QMomp_libEComp_lock_hint_kind = external constant i32
@_QMomp_libEComp_lock_hint_none = external constant i32
@_QMomp_libEComp_lock_hint_nonspeculative = external constant i32
@_QMomp_libEComp_lock_hint_speculative = external constant i32
@_QMomp_libEComp_lock_hint_uncontended = external constant i32
@_QMomp_libEComp_lock_kind = external constant i32
@_QMomp_libEComp_logical_kind = external constant i32
@_QMomp_libEComp_low_lat_mem_alloc = external constant i32
@_QMomp_libEComp_low_lat_mem_space = external constant i32
@_QMomp_libEComp_memspace_handle_kind = external constant i32
@_QMomp_libEComp_nest_lock_kind = external constant i32
@_QMomp_libEComp_null_allocator = external constant i32
@_QMomp_libEComp_pause_hard = external constant i32
@_QMomp_libEComp_pause_resource_kind = external constant i32
@_QMomp_libEComp_pause_soft = external constant i32
@_QMomp_libEComp_proc_bind_close = external constant i32
@_QMomp_libEComp_proc_bind_false = external constant i32
@_QMomp_libEComp_proc_bind_kind = external constant i32
@_QMomp_libEComp_proc_bind_master = external constant i32
@_QMomp_libEComp_proc_bind_spread = external constant i32
@_QMomp_libEComp_proc_bind_true = external constant i32
@_QMomp_libEComp_pteam_mem_alloc = external constant i32
@_QMomp_libEComp_sched_auto = external constant i32
@_QMomp_libEComp_sched_dynamic = external constant i32
@_QMomp_libEComp_sched_guided = external constant i32
@_QMomp_libEComp_sched_kind = external constant i32
@_QMomp_libEComp_sched_static = external constant i32
@_QMomp_libEComp_sync_hint_contended = external constant i32
@_QMomp_libEComp_sync_hint_kind = external constant i32
@_QMomp_libEComp_sync_hint_none = external constant i32
@_QMomp_libEComp_sync_hint_nonspeculative = external constant i32
@_QMomp_libEComp_sync_hint_speculative = external constant i32
@_QMomp_libEComp_sync_hint_uncontended = external constant i32
@_QMomp_libEComp_task_fulfill_event = external constant i32
@_QMomp_libEComp_thread_mem_alloc = external constant i32
@_QMomp_libECopenmp_version = external constant i32
@_QQcl.28612C69372C612C6531332E36653229 = internal constant [16 x i8] c"(a,i7,a,e13.6e2)"
@_QQcl.21557d42704c5c1f18a68415065290ee = internal constant [50 x i8] c"/g/g92/rydahl1/flangtests/src/parallel_region.f90\00"
@_QQcl.54686520726573756C74206F6620286172722831292B61727228 = internal constant [26 x i8] c"The result of (arr(1)+arr("
@_QQcl.2920697320 = internal constant [5 x i8] c") is "
@_QQEnvironmentDefaults = constant ptr null
@0 = private unnamed_addr constant [23 x i8] c";unknown;unknown;0;0;;\00", align 1
@1 = private unnamed_addr constant %struct.ident_t { i32 0, i32 2, i32 0, i32 22, ptr @0 }, align 8

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite)
declare noalias noundef ptr @malloc(i64 noundef) #0

; Function Attrs: mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite)
declare void @free(ptr allocptr nocapture noundef) #1

define void @_QQmain() {
  %1 = alloca i32, i64 1, align 4
  %2 = alloca double, i64 1, align 8
  store i32 1048576, ptr %1, align 4, !tbaa !4
  call void @_QFPomp_subroutine(ptr %1, ptr %2)
  %3 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %4 = call i1 @_FortranAioOutputAscii(ptr %3, ptr @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %5 = load i32, ptr %1, align 4, !tbaa !4
  %6 = call i1 @_FortranAioOutputInteger32(ptr %3, i32 %5)
  %7 = call i1 @_FortranAioOutputAscii(ptr %3, ptr @_QQcl.2920697320, i64 5)
  %8 = load double, ptr %2, align 8, !tbaa !4
  %9 = call i1 @_FortranAioOutputReal64(ptr %3, double %8)
  %10 = call i32 @_FortranAioEndIoStatement(ptr %3)
  ret void
}

define void @_QFPomp_subroutine(ptr %0, ptr %1) {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, i64 1, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 1
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 2
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, i64 1, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = sext i32 %6 to i64
  %8 = icmp sgt i64 %7, 0
  %9 = select i1 %8, i64 %7, i64 0
  %10 = mul i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), %9
  %11 = call ptr @malloc(i64 %10)
  %12 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } { ptr undef, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), i32 20180515, i8 1, i8 28, i8 2, i8 0, [1 x [3 x i64]] [[3 x i64] [i64 1, i64 undef, i64 undef]] }, i64 %9, 7, 0, 1
  %13 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %12, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), 7, 0, 2
  %14 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %13, ptr %11, 0
  %.fca.1.extract173 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 1
  %.fca.2.extract175 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 2
  %.fca.3.extract177 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 3
  %.fca.4.extract179 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 4
  %.fca.5.extract181 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 5
  %.fca.6.extract183 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 6
  %.fca.7.0.0.extract185 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 7, 0, 0
  %.fca.0.insert193 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } poison, ptr %11, 0
  %.fca.1.insert196 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.0.insert193, i64 %.fca.1.extract173, 1
  %.fca.2.insert199 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.1.insert196, i32 %.fca.2.extract175, 2
  %.fca.3.insert202 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.2.insert199, i8 %.fca.3.extract177, 3
  %.fca.4.insert205 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.3.insert202, i8 %.fca.4.extract179, 4
  %.fca.5.insert208 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.4.insert205, i8 %.fca.5.extract181, 5
  %.fca.6.insert211 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.5.insert208, i8 %.fca.6.extract183, 6
  %.fca.7.0.0.insert214 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.6.insert211, i64 %.fca.7.0.0.extract185, 7, 0, 0
  %.fca.7.0.1.insert217 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.0.insert214, i64 %9, 7, 0, 1
  %.fca.7.0.2.insert220 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.1.insert217, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), 7, 0, 2
  store ptr %11, ptr %4, align 8, !tbaa !8
  store i64 %.fca.1.extract173, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 %.fca.2.extract175, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 %.fca.3.extract177, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 %.fca.4.extract179, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 %.fca.5.extract181, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 %.fca.6.extract183, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 %.fca.7.0.0.extract185, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %9, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @1, i32 1, ptr @_QFPomp_subroutine..omp_par, ptr %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.0.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } poison, ptr %.fca.0.load, 0
  %.fca.1.load = load i64, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.1.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.0.insert, i64 %.fca.1.load, 1
  %.fca.2.load = load i32, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.2.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.1.insert, i32 %.fca.2.load, 2
  %.fca.3.load = load i8, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.3.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.2.insert, i8 %.fca.3.load, 3
  %.fca.4.load = load i8, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.4.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.3.insert, i8 %.fca.4.load, 4
  %.fca.5.load = load i8, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.5.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.4.insert, i8 %.fca.5.load, 5
  %.fca.6.load = load i8, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.6.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.5.insert, i8 %.fca.6.load, 6
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.0.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.6.insert, i64 %.fca.7.0.0.load, 7, 0, 0
  %.fca.7.0.1.load = load i64, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.1.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.0.insert, i64 %.fca.7.0.1.load, 7, 0, 1
  %.fca.7.0.2.load = load i64, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %.fca.7.0.2.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.1.insert, i64 %.fca.7.0.2.load, 7, 0, 2
  %15 = sub i64 1, %.fca.7.0.0.load
  %16 = getelementptr double, ptr %.fca.0.load, i64 %15
  %17 = load double, ptr %16, align 8, !tbaa !4
  %18 = load i32, ptr %0, align 4, !tbaa !4
  %19 = sext i32 %18 to i64
  %20 = sub i64 %19, %.fca.7.0.0.load
  %21 = getelementptr double, ptr %.fca.0.load, i64 %20
  %22 = load double, ptr %21, align 8, !tbaa !4
  %23 = fadd contract double %17, %22
  store double %23, ptr %1, align 8, !tbaa !4
  %.fca.0.load43 = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.0.insert44 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } poison, ptr %.fca.0.load43, 0
  %.fca.1.load46 = load i64, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.1.insert47 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.0.insert44, i64 %.fca.1.load46, 1
  %.fca.2.load49 = load i32, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.2.insert50 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.1.insert47, i32 %.fca.2.load49, 2
  %.fca.3.load52 = load i8, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.3.insert53 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.2.insert50, i8 %.fca.3.load52, 3
  %.fca.4.load55 = load i8, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.4.insert56 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.3.insert53, i8 %.fca.4.load55, 4
  %.fca.5.load58 = load i8, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.5.insert59 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.4.insert56, i8 %.fca.5.load58, 5
  %.fca.6.load61 = load i8, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.6.insert62 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.5.insert59, i8 %.fca.6.load61, 6
  %.fca.7.0.0.load64 = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.0.insert65 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.6.insert62, i64 %.fca.7.0.0.load64, 7, 0, 0
  %.fca.7.0.1.load67 = load i64, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.1.insert68 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.0.insert65, i64 %.fca.7.0.1.load67, 7, 0, 1
  %.fca.7.0.2.load70 = load i64, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %.fca.7.0.2.insert71 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.1.insert68, i64 %.fca.7.0.2.load70, 7, 0, 2
  call void @free(ptr %.fca.0.load43)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}

; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = sub i32 %2, 1
  %8 = icmp eq i32 %1, %7
  br i1 %8, label %omp.par.region2, label %omp.par.region3

omp.par.region3:                                  ; preds = %omp.par.entry
  %9 = add i32 %6, %4
  br label %omp.par.region4

omp.par.region4:                                  ; preds = %omp.par.region2, %omp.par.region3
  %.0 = phi i32 [ %3, %omp.par.region2 ], [ %9, %omp.par.region3 ]
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub nsw i64 %11, %10
  %13 = add nsw i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.region4
  %14 = phi i32 [ %39, %omp.par.region6 ], [ %6, %omp.par.region4 ]
  %15 = phi i64 [ %40, %omp.par.region6 ], [ %13, %omp.par.region4 ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %21 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %21, ptr %loadgep_4, align 8, !tbaa !8
  %22 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 0
  %23 = load i64, ptr %22, align 8, !tbaa !8
  %24 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 1
  %25 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 2
  %26 = load ptr, ptr %loadgep_4, align 8, !tbaa !8
  %27 = sext i32 %14 to i64
  %28 = sub i64 %27, %23
  %29 = getelementptr double, ptr %26, i64 %28
  store double %20, ptr %29, align 8, !tbaa !4
  %30 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %30, ptr %loadgep_6, align 8, !tbaa !8
  %31 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 0
  %32 = load i64, ptr %31, align 8, !tbaa !8
  %33 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 1
  %34 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 2
  %35 = load ptr, ptr %loadgep_6, align 8, !tbaa !8
  %36 = sub i64 %27, %32
  %37 = getelementptr double, ptr %35, i64 %36
  %38 = load double, ptr %37, align 8, !tbaa !4
  store double %38, ptr %loadgep_8, align 8, !tbaa !4
  %39 = add i32 %14, 1
  %40 = sub nuw nsw i64 %15, 1
  br label %omp.par.region5

omp.par.region2:                                  ; preds = %omp.par.entry
  br label %omp.par.region4
}

declare ptr @_FortranAioBeginExternalFormattedOutput(ptr, i64, ptr, i32, ptr, i32)

declare zeroext i1 @_FortranAioOutputAscii(ptr, ptr, i64)

declare zeroext i1 @_FortranAioOutputInteger32(ptr, i32)

declare zeroext i1 @_FortranAioOutputReal64(ptr, double)

declare i32 @_FortranAioEndIoStatement(ptr)

; Function Attrs: nounwind
declare i32 @omp_get_thread_num() #3

; Function Attrs: nounwind
declare i32 @omp_get_num_threads() #3

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn
declare ptr @llvm.stacksave() #4

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn
declare void @llvm.stackrestore(ptr) #4

; Function Attrs: nounwind
declare i32 @__kmpc_global_thread_num(ptr) #3

; Function Attrs: nounwind
declare !callback !10 void @__kmpc_fork_call(ptr, i32, ptr, ...) #3

attributes #0 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #1 = { mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #2 = { norecurse nounwind }
attributes #3 = { nounwind }
attributes #4 = { mustprogress nocallback nofree nosync nounwind willreturn }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i32 7, !"openmp", i32 11}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{!5, !5, i64 0}
!5 = !{!"any data access", !6, i64 0}
!6 = !{!"any access", !7, i64 0}
!7 = !{!"Flang Type TBAA Root"}
!8 = !{!9, !9, i64 0}
!9 = !{!"descriptor member", !6, i64 0}
!10 = !{!11}
!11 = !{i64 2, i64 -1, i64 -1, i1 true}
*** IR Dump After GlobalOptPass on [module] ***
; ModuleID = 'FIRModule'
source_filename = "FIRModule"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.ident_t = type { i32, i32, i32, i32, ptr }

@_QQcl.28612C69372C612C6531332E36653229 = internal constant [16 x i8] c"(a,i7,a,e13.6e2)"
@_QQcl.21557d42704c5c1f18a68415065290ee = internal constant [50 x i8] c"/g/g92/rydahl1/flangtests/src/parallel_region.f90\00"
@_QQcl.54686520726573756C74206F6620286172722831292B61727228 = internal constant [26 x i8] c"The result of (arr(1)+arr("
@_QQcl.2920697320 = internal constant [5 x i8] c") is "
@_QQEnvironmentDefaults = local_unnamed_addr constant ptr null
@0 = private unnamed_addr constant [23 x i8] c";unknown;unknown;0;0;;\00", align 1
@1 = private unnamed_addr constant %struct.ident_t { i32 0, i32 2, i32 0, i32 22, ptr @0 }, align 8

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite)
declare noalias noundef ptr @malloc(i64 noundef) local_unnamed_addr #0

; Function Attrs: mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite)
declare void @free(ptr allocptr nocapture noundef) local_unnamed_addr #1

define void @_QQmain() local_unnamed_addr {
  %1 = alloca i32, i64 1, align 4
  %2 = alloca double, i64 1, align 8
  store i32 1048576, ptr %1, align 4, !tbaa !4
  call void @_QFPomp_subroutine(ptr %1, ptr %2)
  %3 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %4 = call i1 @_FortranAioOutputAscii(ptr %3, ptr @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %5 = load i32, ptr %1, align 4, !tbaa !4
  %6 = call i1 @_FortranAioOutputInteger32(ptr %3, i32 %5)
  %7 = call i1 @_FortranAioOutputAscii(ptr %3, ptr @_QQcl.2920697320, i64 5)
  %8 = load double, ptr %2, align 8, !tbaa !4
  %9 = call i1 @_FortranAioOutputReal64(ptr %3, double %8)
  %10 = call i32 @_FortranAioEndIoStatement(ptr %3)
  ret void
}

define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, i64 1, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 1
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 2
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, i64 1, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = sext i32 %6 to i64
  %8 = icmp sgt i64 %7, 0
  %9 = select i1 %8, i64 %7, i64 0
  %10 = mul i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), %9
  %11 = call ptr @malloc(i64 %10)
  %12 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } { ptr undef, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), i32 20180515, i8 1, i8 28, i8 2, i8 0, [1 x [3 x i64]] [[3 x i64] [i64 1, i64 undef, i64 undef]] }, i64 %9, 7, 0, 1
  %13 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %12, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), 7, 0, 2
  %14 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %13, ptr %11, 0
  %.fca.1.extract173 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 1
  %.fca.2.extract175 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 2
  %.fca.3.extract177 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 3
  %.fca.4.extract179 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 4
  %.fca.5.extract181 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 5
  %.fca.6.extract183 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 6
  %.fca.7.0.0.extract185 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 7, 0, 0
  %.fca.0.insert193 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } poison, ptr %11, 0
  %.fca.1.insert196 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.0.insert193, i64 %.fca.1.extract173, 1
  %.fca.2.insert199 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.1.insert196, i32 %.fca.2.extract175, 2
  %.fca.3.insert202 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.2.insert199, i8 %.fca.3.extract177, 3
  %.fca.4.insert205 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.3.insert202, i8 %.fca.4.extract179, 4
  %.fca.5.insert208 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.4.insert205, i8 %.fca.5.extract181, 5
  %.fca.6.insert211 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.5.insert208, i8 %.fca.6.extract183, 6
  %.fca.7.0.0.insert214 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.6.insert211, i64 %.fca.7.0.0.extract185, 7, 0, 0
  %.fca.7.0.1.insert217 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.0.insert214, i64 %9, 7, 0, 1
  %.fca.7.0.2.insert220 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.1.insert217, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), 7, 0, 2
  store ptr %11, ptr %4, align 8, !tbaa !8
  store i64 %.fca.1.extract173, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 %.fca.2.extract175, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 %.fca.3.extract177, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 %.fca.4.extract179, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 %.fca.5.extract181, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 %.fca.6.extract183, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 %.fca.7.0.0.extract185, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %9, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @1, i32 1, ptr @_QFPomp_subroutine..omp_par, ptr %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.0.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } poison, ptr %.fca.0.load, 0
  %.fca.1.load = load i64, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.1.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.0.insert, i64 %.fca.1.load, 1
  %.fca.2.load = load i32, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.2.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.1.insert, i32 %.fca.2.load, 2
  %.fca.3.load = load i8, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.3.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.2.insert, i8 %.fca.3.load, 3
  %.fca.4.load = load i8, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.4.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.3.insert, i8 %.fca.4.load, 4
  %.fca.5.load = load i8, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.5.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.4.insert, i8 %.fca.5.load, 5
  %.fca.6.load = load i8, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.6.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.5.insert, i8 %.fca.6.load, 6
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.0.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.6.insert, i64 %.fca.7.0.0.load, 7, 0, 0
  %.fca.7.0.1.load = load i64, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.1.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.0.insert, i64 %.fca.7.0.1.load, 7, 0, 1
  %.fca.7.0.2.load = load i64, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %.fca.7.0.2.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.1.insert, i64 %.fca.7.0.2.load, 7, 0, 2
  %15 = sub i64 1, %.fca.7.0.0.load
  %16 = getelementptr double, ptr %.fca.0.load, i64 %15
  %17 = load double, ptr %16, align 8, !tbaa !4
  %18 = load i32, ptr %0, align 4, !tbaa !4
  %19 = sext i32 %18 to i64
  %20 = sub i64 %19, %.fca.7.0.0.load
  %21 = getelementptr double, ptr %.fca.0.load, i64 %20
  %22 = load double, ptr %21, align 8, !tbaa !4
  %23 = fadd contract double %17, %22
  store double %23, ptr %1, align 8, !tbaa !4
  %.fca.0.load43 = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.0.insert44 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } poison, ptr %.fca.0.load43, 0
  %.fca.1.load46 = load i64, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.1.insert47 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.0.insert44, i64 %.fca.1.load46, 1
  %.fca.2.load49 = load i32, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.2.insert50 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.1.insert47, i32 %.fca.2.load49, 2
  %.fca.3.load52 = load i8, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.3.insert53 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.2.insert50, i8 %.fca.3.load52, 3
  %.fca.4.load55 = load i8, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.4.insert56 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.3.insert53, i8 %.fca.4.load55, 4
  %.fca.5.load58 = load i8, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.5.insert59 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.4.insert56, i8 %.fca.5.load58, 5
  %.fca.6.load61 = load i8, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.6.insert62 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.5.insert59, i8 %.fca.6.load61, 6
  %.fca.7.0.0.load64 = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.0.insert65 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.6.insert62, i64 %.fca.7.0.0.load64, 7, 0, 0
  %.fca.7.0.1.load67 = load i64, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.1.insert68 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.0.insert65, i64 %.fca.7.0.1.load67, 7, 0, 1
  %.fca.7.0.2.load70 = load i64, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %.fca.7.0.2.insert71 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.1.insert68, i64 %.fca.7.0.2.load70, 7, 0, 2
  call void @free(ptr %.fca.0.load43)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}

; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = sub i32 %2, 1
  %8 = icmp eq i32 %1, %7
  br i1 %8, label %omp.par.region2, label %omp.par.region3

omp.par.region3:                                  ; preds = %omp.par.entry
  %9 = add i32 %6, %4
  br label %omp.par.region4

omp.par.region4:                                  ; preds = %omp.par.region2, %omp.par.region3
  %.0 = phi i32 [ %3, %omp.par.region2 ], [ %9, %omp.par.region3 ]
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub nsw i64 %11, %10
  %13 = add nsw i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.region4
  %14 = phi i32 [ %39, %omp.par.region6 ], [ %6, %omp.par.region4 ]
  %15 = phi i64 [ %40, %omp.par.region6 ], [ %13, %omp.par.region4 ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %21 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %21, ptr %loadgep_4, align 8, !tbaa !8
  %22 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 0
  %23 = load i64, ptr %22, align 8, !tbaa !8
  %24 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 1
  %25 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 2
  %26 = load ptr, ptr %loadgep_4, align 8, !tbaa !8
  %27 = sext i32 %14 to i64
  %28 = sub i64 %27, %23
  %29 = getelementptr double, ptr %26, i64 %28
  store double %20, ptr %29, align 8, !tbaa !4
  %30 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %30, ptr %loadgep_6, align 8, !tbaa !8
  %31 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 0
  %32 = load i64, ptr %31, align 8, !tbaa !8
  %33 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 1
  %34 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 2
  %35 = load ptr, ptr %loadgep_6, align 8, !tbaa !8
  %36 = sub i64 %27, %32
  %37 = getelementptr double, ptr %35, i64 %36
  %38 = load double, ptr %37, align 8, !tbaa !4
  store double %38, ptr %loadgep_8, align 8, !tbaa !4
  %39 = add i32 %14, 1
  %40 = sub nuw nsw i64 %15, 1
  br label %omp.par.region5

omp.par.region2:                                  ; preds = %omp.par.entry
  br label %omp.par.region4
}

declare ptr @_FortranAioBeginExternalFormattedOutput(ptr, i64, ptr, i32, ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputAscii(ptr, ptr, i64) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputInteger32(ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputReal64(ptr, double) local_unnamed_addr

declare i32 @_FortranAioEndIoStatement(ptr) local_unnamed_addr

; Function Attrs: nounwind
declare i32 @omp_get_thread_num() local_unnamed_addr #3

; Function Attrs: nounwind
declare i32 @omp_get_num_threads() local_unnamed_addr #3

; Function Attrs: nounwind
declare i32 @__kmpc_global_thread_num(ptr) local_unnamed_addr #3

; Function Attrs: nounwind
declare !callback !10 void @__kmpc_fork_call(ptr, i32, ptr, ...) local_unnamed_addr #3

attributes #0 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #1 = { mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #2 = { norecurse nounwind }
attributes #3 = { nounwind }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i32 7, !"openmp", i32 11}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{!5, !5, i64 0}
!5 = !{!"any data access", !6, i64 0}
!6 = !{!"any access", !7, i64 0}
!7 = !{!"Flang Type TBAA Root"}
!8 = !{!9, !9, i64 0}
!9 = !{!"descriptor member", !6, i64 0}
!10 = !{!11}
!11 = !{i64 2, i64 -1, i64 -1, i1 true}
*** IR Dump After PromotePass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %1 = alloca i32, i64 1, align 4
  %2 = alloca double, i64 1, align 8
  store i32 1048576, ptr %1, align 4, !tbaa !4
  call void @_QFPomp_subroutine(ptr %1, ptr %2)
  %3 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %4 = call i1 @_FortranAioOutputAscii(ptr %3, ptr @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %5 = load i32, ptr %1, align 4, !tbaa !4
  %6 = call i1 @_FortranAioOutputInteger32(ptr %3, i32 %5)
  %7 = call i1 @_FortranAioOutputAscii(ptr %3, ptr @_QQcl.2920697320, i64 5)
  %8 = load double, ptr %2, align 8, !tbaa !4
  %9 = call i1 @_FortranAioOutputReal64(ptr %3, double %8)
  %10 = call i32 @_FortranAioEndIoStatement(ptr %3)
  ret void
}
*** IR Dump After InstCombinePass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %1 = alloca i32, align 4
  %2 = alloca double, align 8
  store i32 1048576, ptr %1, align 4, !tbaa !4
  call void @_QFPomp_subroutine(ptr nonnull %1, ptr nonnull %2)
  %3 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %4 = call i1 @_FortranAioOutputAscii(ptr %3, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %5 = load i32, ptr %1, align 4, !tbaa !4
  %6 = call i1 @_FortranAioOutputInteger32(ptr %3, i32 %5)
  %7 = call i1 @_FortranAioOutputAscii(ptr %3, ptr nonnull @_QQcl.2920697320, i64 5)
  %8 = load double, ptr %2, align 8, !tbaa !4
  %9 = call i1 @_FortranAioOutputReal64(ptr %3, double %8)
  %10 = call i32 @_FortranAioEndIoStatement(ptr %3)
  ret void
}
*** IR Dump After SimplifyCFGPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %1 = alloca i32, align 4
  %2 = alloca double, align 8
  store i32 1048576, ptr %1, align 4, !tbaa !4
  call void @_QFPomp_subroutine(ptr nonnull %1, ptr nonnull %2)
  %3 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %4 = call i1 @_FortranAioOutputAscii(ptr %3, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %5 = load i32, ptr %1, align 4, !tbaa !4
  %6 = call i1 @_FortranAioOutputInteger32(ptr %3, i32 %5)
  %7 = call i1 @_FortranAioOutputAscii(ptr %3, ptr nonnull @_QQcl.2920697320, i64 5)
  %8 = load double, ptr %2, align 8, !tbaa !4
  %9 = call i1 @_FortranAioOutputReal64(ptr %3, double %8)
  %10 = call i32 @_FortranAioEndIoStatement(ptr %3)
  ret void
}
*** IR Dump After PromotePass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, i64 1, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 1
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i32 0, i32 7, i32 0, i32 2
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, i64 1, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = sext i32 %6 to i64
  %8 = icmp sgt i64 %7, 0
  %9 = select i1 %8, i64 %7, i64 0
  %10 = mul i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), %9
  %11 = call ptr @malloc(i64 %10)
  %12 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } { ptr undef, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), i32 20180515, i8 1, i8 28, i8 2, i8 0, [1 x [3 x i64]] [[3 x i64] [i64 1, i64 undef, i64 undef]] }, i64 %9, 7, 0, 1
  %13 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %12, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), 7, 0, 2
  %14 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %13, ptr %11, 0
  %.fca.1.extract173 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 1
  %.fca.2.extract175 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 2
  %.fca.3.extract177 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 3
  %.fca.4.extract179 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 4
  %.fca.5.extract181 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 5
  %.fca.6.extract183 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 6
  %.fca.7.0.0.extract185 = extractvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %14, 7, 0, 0
  %.fca.0.insert193 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } poison, ptr %11, 0
  %.fca.1.insert196 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.0.insert193, i64 %.fca.1.extract173, 1
  %.fca.2.insert199 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.1.insert196, i32 %.fca.2.extract175, 2
  %.fca.3.insert202 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.2.insert199, i8 %.fca.3.extract177, 3
  %.fca.4.insert205 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.3.insert202, i8 %.fca.4.extract179, 4
  %.fca.5.insert208 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.4.insert205, i8 %.fca.5.extract181, 5
  %.fca.6.insert211 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.5.insert208, i8 %.fca.6.extract183, 6
  %.fca.7.0.0.insert214 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.6.insert211, i64 %.fca.7.0.0.extract185, 7, 0, 0
  %.fca.7.0.1.insert217 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.0.insert214, i64 %9, 7, 0, 1
  %.fca.7.0.2.insert220 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.1.insert217, i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), 7, 0, 2
  store ptr %11, ptr %4, align 8, !tbaa !8
  store i64 %.fca.1.extract173, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 %.fca.2.extract175, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 %.fca.3.extract177, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 %.fca.4.extract179, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 %.fca.5.extract181, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 %.fca.6.extract183, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 %.fca.7.0.0.extract185, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %9, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i32 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @1, i32 1, ptr @_QFPomp_subroutine..omp_par, ptr %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.0.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } poison, ptr %.fca.0.load, 0
  %.fca.1.load = load i64, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.1.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.0.insert, i64 %.fca.1.load, 1
  %.fca.2.load = load i32, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.2.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.1.insert, i32 %.fca.2.load, 2
  %.fca.3.load = load i8, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.3.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.2.insert, i8 %.fca.3.load, 3
  %.fca.4.load = load i8, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.4.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.3.insert, i8 %.fca.4.load, 4
  %.fca.5.load = load i8, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.5.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.4.insert, i8 %.fca.5.load, 5
  %.fca.6.load = load i8, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.6.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.5.insert, i8 %.fca.6.load, 6
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.0.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.6.insert, i64 %.fca.7.0.0.load, 7, 0, 0
  %.fca.7.0.1.load = load i64, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.1.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.0.insert, i64 %.fca.7.0.1.load, 7, 0, 1
  %.fca.7.0.2.load = load i64, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %.fca.7.0.2.insert = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.1.insert, i64 %.fca.7.0.2.load, 7, 0, 2
  %15 = sub i64 1, %.fca.7.0.0.load
  %16 = getelementptr double, ptr %.fca.0.load, i64 %15
  %17 = load double, ptr %16, align 8, !tbaa !4
  %18 = load i32, ptr %0, align 4, !tbaa !4
  %19 = sext i32 %18 to i64
  %20 = sub i64 %19, %.fca.7.0.0.load
  %21 = getelementptr double, ptr %.fca.0.load, i64 %20
  %22 = load double, ptr %21, align 8, !tbaa !4
  %23 = fadd contract double %17, %22
  store double %23, ptr %1, align 8, !tbaa !4
  %.fca.0.load43 = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.0.insert44 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } poison, ptr %.fca.0.load43, 0
  %.fca.1.load46 = load i64, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.1.insert47 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.0.insert44, i64 %.fca.1.load46, 1
  %.fca.2.load49 = load i32, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.2.insert50 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.1.insert47, i32 %.fca.2.load49, 2
  %.fca.3.load52 = load i8, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.3.insert53 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.2.insert50, i8 %.fca.3.load52, 3
  %.fca.4.load55 = load i8, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.4.insert56 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.3.insert53, i8 %.fca.4.load55, 4
  %.fca.5.load58 = load i8, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.5.insert59 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.4.insert56, i8 %.fca.5.load58, 5
  %.fca.6.load61 = load i8, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.6.insert62 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.5.insert59, i8 %.fca.6.load61, 6
  %.fca.7.0.0.load64 = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.0.insert65 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.6.insert62, i64 %.fca.7.0.0.load64, 7, 0, 0
  %.fca.7.0.1.load67 = load i64, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.1.insert68 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.0.insert65, i64 %.fca.7.0.1.load67, 7, 0, 1
  %.fca.7.0.2.load70 = load i64, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %.fca.7.0.2.insert71 = insertvalue { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %.fca.7.0.1.insert68, i64 %.fca.7.0.2.load70, 7, 0, 2
  call void @free(ptr %.fca.0.load43)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 ptrtoint (ptr getelementptr (double, ptr null, i32 1) to i64), ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After InstCombinePass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  %.fca.0.load43 = load ptr, ptr %4, align 8, !tbaa !8
  call void @free(ptr %.fca.0.load43)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After SimplifyCFGPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  %.fca.0.load43 = load ptr, ptr %4, align 8, !tbaa !8
  call void @free(ptr %.fca.0.load43)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After PromotePass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i32 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = sub i32 %2, 1
  %8 = icmp eq i32 %1, %7
  br i1 %8, label %omp.par.region2, label %omp.par.region3

omp.par.region3:                                  ; preds = %omp.par.entry
  %9 = add i32 %6, %4
  br label %omp.par.region4

omp.par.region4:                                  ; preds = %omp.par.region2, %omp.par.region3
  %.0 = phi i32 [ %3, %omp.par.region2 ], [ %9, %omp.par.region3 ]
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub nsw i64 %11, %10
  %13 = add nsw i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.region4
  %14 = phi i32 [ %39, %omp.par.region6 ], [ %6, %omp.par.region4 ]
  %15 = phi i64 [ %40, %omp.par.region6 ], [ %13, %omp.par.region4 ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %21 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %21, ptr %loadgep_4, align 8, !tbaa !8
  %22 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 0
  %23 = load i64, ptr %22, align 8, !tbaa !8
  %24 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 1
  %25 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i32 0, i32 7, i64 0, i32 2
  %26 = load ptr, ptr %loadgep_4, align 8, !tbaa !8
  %27 = sext i32 %14 to i64
  %28 = sub i64 %27, %23
  %29 = getelementptr double, ptr %26, i64 %28
  store double %20, ptr %29, align 8, !tbaa !4
  %30 = load { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, align 8, !tbaa !8
  store { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] } %30, ptr %loadgep_6, align 8, !tbaa !8
  %31 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 0
  %32 = load i64, ptr %31, align 8, !tbaa !8
  %33 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 1
  %34 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i32 0, i32 7, i64 0, i32 2
  %35 = load ptr, ptr %loadgep_6, align 8, !tbaa !8
  %36 = sub i64 %27, %32
  %37 = getelementptr double, ptr %35, i64 %36
  %38 = load double, ptr %37, align 8, !tbaa !4
  store double %38, ptr %loadgep_8, align 8, !tbaa !4
  %39 = add i32 %14, 1
  %40 = sub nuw nsw i64 %15, 1
  br label %omp.par.region5

omp.par.region2:                                  ; preds = %omp.par.entry
  br label %omp.par.region4
}
*** IR Dump After InstCombinePass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  br i1 %8, label %omp.par.region2, label %omp.par.region3

omp.par.region3:                                  ; preds = %omp.par.entry
  %9 = add i32 %6, %4
  br label %omp.par.region4

omp.par.region4:                                  ; preds = %omp.par.region2, %omp.par.region3
  %.0 = phi i32 [ %3, %omp.par.region2 ], [ %9, %omp.par.region3 ]
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub nsw i64 %11, %10
  %13 = add nsw i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.region4
  %14 = phi i32 [ %33, %omp.par.region6 ], [ %6, %omp.par.region4 ]
  %15 = phi i64 [ %34, %omp.par.region6 ], [ %13, %omp.par.region4 ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = load ptr, ptr %loadgep_4, align 8, !tbaa !8
  %24 = sext i32 %14 to i64
  %25 = sub i64 %24, %22
  %26 = getelementptr double, ptr %23, i64 %25
  store double %20, ptr %26, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt60 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack61 = load i64, ptr %.elt60, align 8, !tbaa !8
  %.elt62 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack63 = load i32, ptr %.elt62, align 8, !tbaa !8
  %.elt64 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack65 = load i8, ptr %.elt64, align 4, !tbaa !8
  %.elt66 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack67 = load i8, ptr %.elt66, align 1, !tbaa !8
  %.elt68 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack69 = load i8, ptr %.elt68, align 2, !tbaa !8
  %.elt70 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack71 = load i8, ptr %.elt70, align 1, !tbaa !8
  %.elt72 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack73.unpack.unpack = load i64, ptr %.elt72, align 8, !tbaa !8
  %.unpack73.unpack.elt75 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack73.unpack.elt75, align 8, !tbaa !8
  %.unpack73.unpack.elt77 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack73.unpack.elt77, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %27 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %28 = load i64, ptr %27, align 8, !tbaa !8
  %29 = load ptr, ptr %loadgep_6, align 8, !tbaa !8
  %30 = sub i64 %24, %28
  %31 = getelementptr double, ptr %29, i64 %30
  %32 = load double, ptr %31, align 8, !tbaa !4
  store double %32, ptr %loadgep_8, align 8, !tbaa !4
  %33 = add i32 %14, 1
  %34 = add nsw i64 %15, -1
  br label %omp.par.region5

omp.par.region2:                                  ; preds = %omp.par.entry
  br label %omp.par.region4
}
*** IR Dump After SimplifyCFGPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub nsw i64 %11, %10
  %13 = add nsw i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %33, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %34, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = load ptr, ptr %loadgep_4, align 8, !tbaa !8
  %24 = sext i32 %14 to i64
  %25 = sub i64 %24, %22
  %26 = getelementptr double, ptr %23, i64 %25
  store double %20, ptr %26, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt60 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack61 = load i64, ptr %.elt60, align 8, !tbaa !8
  %.elt62 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack63 = load i32, ptr %.elt62, align 8, !tbaa !8
  %.elt64 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack65 = load i8, ptr %.elt64, align 4, !tbaa !8
  %.elt66 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack67 = load i8, ptr %.elt66, align 1, !tbaa !8
  %.elt68 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack69 = load i8, ptr %.elt68, align 2, !tbaa !8
  %.elt70 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack71 = load i8, ptr %.elt70, align 1, !tbaa !8
  %.elt72 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack73.unpack.unpack = load i64, ptr %.elt72, align 8, !tbaa !8
  %.unpack73.unpack.elt75 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack73.unpack.elt75, align 8, !tbaa !8
  %.unpack73.unpack.elt77 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack73.unpack.elt77, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %27 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %28 = load i64, ptr %27, align 8, !tbaa !8
  %29 = load ptr, ptr %loadgep_6, align 8, !tbaa !8
  %30 = sub i64 %24, %28
  %31 = getelementptr double, ptr %29, i64 %30
  %32 = load double, ptr %31, align 8, !tbaa !4
  store double %32, ptr %loadgep_8, align 8, !tbaa !4
  %33 = add i32 %14, 1
  %34 = add nsw i64 %15, -1
  br label %omp.par.region5
}
*** IR Dump After RequireAnalysisPass<llvm::GlobalsAA, llvm::Module> on [module] ***
; ModuleID = 'FIRModule'
source_filename = "FIRModule"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.ident_t = type { i32, i32, i32, i32, ptr }

@_QQcl.28612C69372C612C6531332E36653229 = internal constant [16 x i8] c"(a,i7,a,e13.6e2)"
@_QQcl.21557d42704c5c1f18a68415065290ee = internal constant [50 x i8] c"/g/g92/rydahl1/flangtests/src/parallel_region.f90\00"
@_QQcl.54686520726573756C74206F6620286172722831292B61727228 = internal constant [26 x i8] c"The result of (arr(1)+arr("
@_QQcl.2920697320 = internal constant [5 x i8] c") is "
@_QQEnvironmentDefaults = local_unnamed_addr constant ptr null
@0 = private unnamed_addr constant [23 x i8] c";unknown;unknown;0;0;;\00", align 1
@1 = private unnamed_addr constant %struct.ident_t { i32 0, i32 2, i32 0, i32 22, ptr @0 }, align 8

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite)
declare noalias noundef ptr @malloc(i64 noundef) local_unnamed_addr #0

; Function Attrs: mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite)
declare void @free(ptr allocptr nocapture noundef) local_unnamed_addr #1

define void @_QQmain() local_unnamed_addr {
  %1 = alloca i32, align 4
  %2 = alloca double, align 8
  store i32 1048576, ptr %1, align 4, !tbaa !4
  call void @_QFPomp_subroutine(ptr nonnull %1, ptr nonnull %2)
  %3 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %4 = call i1 @_FortranAioOutputAscii(ptr %3, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %5 = load i32, ptr %1, align 4, !tbaa !4
  %6 = call i1 @_FortranAioOutputInteger32(ptr %3, i32 %5)
  %7 = call i1 @_FortranAioOutputAscii(ptr %3, ptr nonnull @_QQcl.2920697320, i64 5)
  %8 = load double, ptr %2, align 8, !tbaa !4
  %9 = call i1 @_FortranAioOutputReal64(ptr %3, double %8)
  %10 = call i32 @_FortranAioEndIoStatement(ptr %3)
  ret void
}

define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  %.fca.0.load43 = load ptr, ptr %4, align 8, !tbaa !8
  call void @free(ptr %.fca.0.load43)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}

; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub nsw i64 %11, %10
  %13 = add nsw i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %33, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %34, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = load ptr, ptr %loadgep_4, align 8, !tbaa !8
  %24 = sext i32 %14 to i64
  %25 = sub i64 %24, %22
  %26 = getelementptr double, ptr %23, i64 %25
  store double %20, ptr %26, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt60 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack61 = load i64, ptr %.elt60, align 8, !tbaa !8
  %.elt62 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack63 = load i32, ptr %.elt62, align 8, !tbaa !8
  %.elt64 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack65 = load i8, ptr %.elt64, align 4, !tbaa !8
  %.elt66 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack67 = load i8, ptr %.elt66, align 1, !tbaa !8
  %.elt68 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack69 = load i8, ptr %.elt68, align 2, !tbaa !8
  %.elt70 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack71 = load i8, ptr %.elt70, align 1, !tbaa !8
  %.elt72 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack73.unpack.unpack = load i64, ptr %.elt72, align 8, !tbaa !8
  %.unpack73.unpack.elt75 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack73.unpack.elt75, align 8, !tbaa !8
  %.unpack73.unpack.elt77 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack73.unpack.elt77, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %27 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %28 = load i64, ptr %27, align 8, !tbaa !8
  %29 = load ptr, ptr %loadgep_6, align 8, !tbaa !8
  %30 = sub i64 %24, %28
  %31 = getelementptr double, ptr %29, i64 %30
  %32 = load double, ptr %31, align 8, !tbaa !4
  store double %32, ptr %loadgep_8, align 8, !tbaa !4
  %33 = add i32 %14, 1
  %34 = add nsw i64 %15, -1
  br label %omp.par.region5
}

declare ptr @_FortranAioBeginExternalFormattedOutput(ptr, i64, ptr, i32, ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputAscii(ptr, ptr, i64) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputInteger32(ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputReal64(ptr, double) local_unnamed_addr

declare i32 @_FortranAioEndIoStatement(ptr) local_unnamed_addr

; Function Attrs: nounwind
declare i32 @omp_get_thread_num() local_unnamed_addr #3

; Function Attrs: nounwind
declare i32 @omp_get_num_threads() local_unnamed_addr #3

; Function Attrs: nounwind
declare i32 @__kmpc_global_thread_num(ptr) local_unnamed_addr #3

; Function Attrs: nounwind
declare !callback !10 void @__kmpc_fork_call(ptr, i32, ptr, ...) local_unnamed_addr #3

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.smax.i64(i64, i64) #4

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #4

attributes #0 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #1 = { mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #2 = { norecurse nounwind }
attributes #3 = { nounwind }
attributes #4 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i32 7, !"openmp", i32 11}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{!5, !5, i64 0}
!5 = !{!"any data access", !6, i64 0}
!6 = !{!"any access", !7, i64 0}
!7 = !{!"Flang Type TBAA Root"}
!8 = !{!9, !9, i64 0}
!9 = !{!"descriptor member", !6, i64 0}
!10 = !{!11}
!11 = !{i64 2, i64 -1, i64 -1, i1 true}
*** IR Dump After InvalidateAnalysisPass<llvm::AAManager> on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %1 = alloca i32, align 4
  %2 = alloca double, align 8
  store i32 1048576, ptr %1, align 4, !tbaa !4
  call void @_QFPomp_subroutine(ptr nonnull %1, ptr nonnull %2)
  %3 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %4 = call i1 @_FortranAioOutputAscii(ptr %3, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %5 = load i32, ptr %1, align 4, !tbaa !4
  %6 = call i1 @_FortranAioOutputInteger32(ptr %3, i32 %5)
  %7 = call i1 @_FortranAioOutputAscii(ptr %3, ptr nonnull @_QQcl.2920697320, i64 5)
  %8 = load double, ptr %2, align 8, !tbaa !4
  %9 = call i1 @_FortranAioOutputReal64(ptr %3, double %8)
  %10 = call i32 @_FortranAioEndIoStatement(ptr %3)
  ret void
}
*** IR Dump After InvalidateAnalysisPass<llvm::AAManager> on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  %.fca.0.load43 = load ptr, ptr %4, align 8, !tbaa !8
  call void @free(ptr %.fca.0.load43)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After InvalidateAnalysisPass<llvm::AAManager> on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub nsw i64 %11, %10
  %13 = add nsw i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %33, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %34, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = load ptr, ptr %loadgep_4, align 8, !tbaa !8
  %24 = sext i32 %14 to i64
  %25 = sub i64 %24, %22
  %26 = getelementptr double, ptr %23, i64 %25
  store double %20, ptr %26, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt60 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack61 = load i64, ptr %.elt60, align 8, !tbaa !8
  %.elt62 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack63 = load i32, ptr %.elt62, align 8, !tbaa !8
  %.elt64 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack65 = load i8, ptr %.elt64, align 4, !tbaa !8
  %.elt66 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack67 = load i8, ptr %.elt66, align 1, !tbaa !8
  %.elt68 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack69 = load i8, ptr %.elt68, align 2, !tbaa !8
  %.elt70 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack71 = load i8, ptr %.elt70, align 1, !tbaa !8
  %.elt72 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack73.unpack.unpack = load i64, ptr %.elt72, align 8, !tbaa !8
  %.unpack73.unpack.elt75 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack73.unpack.elt75, align 8, !tbaa !8
  %.unpack73.unpack.elt77 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack73.unpack.elt77, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %27 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %28 = load i64, ptr %27, align 8, !tbaa !8
  %29 = load ptr, ptr %loadgep_6, align 8, !tbaa !8
  %30 = sub i64 %24, %28
  %31 = getelementptr double, ptr %29, i64 %30
  %32 = load double, ptr %31, align 8, !tbaa !4
  store double %32, ptr %loadgep_8, align 8, !tbaa !4
  %33 = add i32 %14, 1
  %34 = add nsw i64 %15, -1
  br label %omp.par.region5
}
*** IR Dump After RequireAnalysisPass<llvm::ProfileSummaryAnalysis, llvm::Module> on [module] ***
; ModuleID = 'FIRModule'
source_filename = "FIRModule"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.ident_t = type { i32, i32, i32, i32, ptr }

@_QQcl.28612C69372C612C6531332E36653229 = internal constant [16 x i8] c"(a,i7,a,e13.6e2)"
@_QQcl.21557d42704c5c1f18a68415065290ee = internal constant [50 x i8] c"/g/g92/rydahl1/flangtests/src/parallel_region.f90\00"
@_QQcl.54686520726573756C74206F6620286172722831292B61727228 = internal constant [26 x i8] c"The result of (arr(1)+arr("
@_QQcl.2920697320 = internal constant [5 x i8] c") is "
@_QQEnvironmentDefaults = local_unnamed_addr constant ptr null
@0 = private unnamed_addr constant [23 x i8] c";unknown;unknown;0;0;;\00", align 1
@1 = private unnamed_addr constant %struct.ident_t { i32 0, i32 2, i32 0, i32 22, ptr @0 }, align 8

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite)
declare noalias noundef ptr @malloc(i64 noundef) local_unnamed_addr #0

; Function Attrs: mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite)
declare void @free(ptr allocptr nocapture noundef) local_unnamed_addr #1

define void @_QQmain() local_unnamed_addr {
  %1 = alloca i32, align 4
  %2 = alloca double, align 8
  store i32 1048576, ptr %1, align 4, !tbaa !4
  call void @_QFPomp_subroutine(ptr nonnull %1, ptr nonnull %2)
  %3 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %4 = call i1 @_FortranAioOutputAscii(ptr %3, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %5 = load i32, ptr %1, align 4, !tbaa !4
  %6 = call i1 @_FortranAioOutputInteger32(ptr %3, i32 %5)
  %7 = call i1 @_FortranAioOutputAscii(ptr %3, ptr nonnull @_QQcl.2920697320, i64 5)
  %8 = load double, ptr %2, align 8, !tbaa !4
  %9 = call i1 @_FortranAioOutputReal64(ptr %3, double %8)
  %10 = call i32 @_FortranAioEndIoStatement(ptr %3)
  ret void
}

define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  %.fca.0.load43 = load ptr, ptr %4, align 8, !tbaa !8
  call void @free(ptr %.fca.0.load43)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}

; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub nsw i64 %11, %10
  %13 = add nsw i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %33, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %34, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = load ptr, ptr %loadgep_4, align 8, !tbaa !8
  %24 = sext i32 %14 to i64
  %25 = sub i64 %24, %22
  %26 = getelementptr double, ptr %23, i64 %25
  store double %20, ptr %26, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt60 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack61 = load i64, ptr %.elt60, align 8, !tbaa !8
  %.elt62 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack63 = load i32, ptr %.elt62, align 8, !tbaa !8
  %.elt64 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack65 = load i8, ptr %.elt64, align 4, !tbaa !8
  %.elt66 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack67 = load i8, ptr %.elt66, align 1, !tbaa !8
  %.elt68 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack69 = load i8, ptr %.elt68, align 2, !tbaa !8
  %.elt70 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack71 = load i8, ptr %.elt70, align 1, !tbaa !8
  %.elt72 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack73.unpack.unpack = load i64, ptr %.elt72, align 8, !tbaa !8
  %.unpack73.unpack.elt75 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack73.unpack.elt75, align 8, !tbaa !8
  %.unpack73.unpack.elt77 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack73.unpack.elt77, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %27 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %28 = load i64, ptr %27, align 8, !tbaa !8
  %29 = load ptr, ptr %loadgep_6, align 8, !tbaa !8
  %30 = sub i64 %24, %28
  %31 = getelementptr double, ptr %29, i64 %30
  %32 = load double, ptr %31, align 8, !tbaa !4
  store double %32, ptr %loadgep_8, align 8, !tbaa !4
  %33 = add i32 %14, 1
  %34 = add nsw i64 %15, -1
  br label %omp.par.region5
}

declare ptr @_FortranAioBeginExternalFormattedOutput(ptr, i64, ptr, i32, ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputAscii(ptr, ptr, i64) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputInteger32(ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputReal64(ptr, double) local_unnamed_addr

declare i32 @_FortranAioEndIoStatement(ptr) local_unnamed_addr

; Function Attrs: nounwind
declare i32 @omp_get_thread_num() local_unnamed_addr #3

; Function Attrs: nounwind
declare i32 @omp_get_num_threads() local_unnamed_addr #3

; Function Attrs: nounwind
declare i32 @__kmpc_global_thread_num(ptr) local_unnamed_addr #3

; Function Attrs: nounwind
declare !callback !10 void @__kmpc_fork_call(ptr, i32, ptr, ...) local_unnamed_addr #3

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.smax.i64(i64, i64) #4

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #4

attributes #0 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #1 = { mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #2 = { norecurse nounwind }
attributes #3 = { nounwind }
attributes #4 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i32 7, !"openmp", i32 11}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{!5, !5, i64 0}
!5 = !{!"any data access", !6, i64 0}
!6 = !{!"any access", !7, i64 0}
!7 = !{!"Flang Type TBAA Root"}
!8 = !{!9, !9, i64 0}
!9 = !{!"descriptor member", !6, i64 0}
!10 = !{!11}
!11 = !{i64 2, i64 -1, i64 -1, i1 true}
*** IR Dump After InlinerPass on (_QFPomp_subroutine..omp_par) ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub nsw i64 %11, %10
  %13 = add nsw i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %33, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %34, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = load ptr, ptr %loadgep_4, align 8, !tbaa !8
  %24 = sext i32 %14 to i64
  %25 = sub i64 %24, %22
  %26 = getelementptr double, ptr %23, i64 %25
  store double %20, ptr %26, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt60 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack61 = load i64, ptr %.elt60, align 8, !tbaa !8
  %.elt62 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack63 = load i32, ptr %.elt62, align 8, !tbaa !8
  %.elt64 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack65 = load i8, ptr %.elt64, align 4, !tbaa !8
  %.elt66 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack67 = load i8, ptr %.elt66, align 1, !tbaa !8
  %.elt68 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack69 = load i8, ptr %.elt68, align 2, !tbaa !8
  %.elt70 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack71 = load i8, ptr %.elt70, align 1, !tbaa !8
  %.elt72 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack73.unpack.unpack = load i64, ptr %.elt72, align 8, !tbaa !8
  %.unpack73.unpack.elt75 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack73.unpack.elt75, align 8, !tbaa !8
  %.unpack73.unpack.elt77 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack73.unpack.elt77, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %27 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %28 = load i64, ptr %27, align 8, !tbaa !8
  %29 = load ptr, ptr %loadgep_6, align 8, !tbaa !8
  %30 = sub i64 %24, %28
  %31 = getelementptr double, ptr %29, i64 %30
  %32 = load double, ptr %31, align 8, !tbaa !4
  store double %32, ptr %loadgep_8, align 8, !tbaa !4
  %33 = add i32 %14, 1
  %34 = add nsw i64 %15, -1
  br label %omp.par.region5
}
*** IR Dump After InlinerPass on (_QFPomp_subroutine..omp_par) ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub nsw i64 %11, %10
  %13 = add nsw i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %33, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %34, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = load ptr, ptr %loadgep_4, align 8, !tbaa !8
  %24 = sext i32 %14 to i64
  %25 = sub i64 %24, %22
  %26 = getelementptr double, ptr %23, i64 %25
  store double %20, ptr %26, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt60 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack61 = load i64, ptr %.elt60, align 8, !tbaa !8
  %.elt62 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack63 = load i32, ptr %.elt62, align 8, !tbaa !8
  %.elt64 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack65 = load i8, ptr %.elt64, align 4, !tbaa !8
  %.elt66 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack67 = load i8, ptr %.elt66, align 1, !tbaa !8
  %.elt68 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack69 = load i8, ptr %.elt68, align 2, !tbaa !8
  %.elt70 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack71 = load i8, ptr %.elt70, align 1, !tbaa !8
  %.elt72 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack73.unpack.unpack = load i64, ptr %.elt72, align 8, !tbaa !8
  %.unpack73.unpack.elt75 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack73.unpack.elt75, align 8, !tbaa !8
  %.unpack73.unpack.elt77 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack73.unpack.elt77, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %27 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %28 = load i64, ptr %27, align 8, !tbaa !8
  %29 = load ptr, ptr %loadgep_6, align 8, !tbaa !8
  %30 = sub i64 %24, %28
  %31 = getelementptr double, ptr %29, i64 %30
  %32 = load double, ptr %31, align 8, !tbaa !4
  store double %32, ptr %loadgep_8, align 8, !tbaa !4
  %33 = add i32 %14, 1
  %34 = add nsw i64 %15, -1
  br label %omp.par.region5
}
*** IR Dump After PostOrderFunctionAttrsPass on (_QFPomp_subroutine..omp_par) ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub nsw i64 %11, %10
  %13 = add nsw i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %33, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %34, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = load ptr, ptr %loadgep_4, align 8, !tbaa !8
  %24 = sext i32 %14 to i64
  %25 = sub i64 %24, %22
  %26 = getelementptr double, ptr %23, i64 %25
  store double %20, ptr %26, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt60 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack61 = load i64, ptr %.elt60, align 8, !tbaa !8
  %.elt62 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack63 = load i32, ptr %.elt62, align 8, !tbaa !8
  %.elt64 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack65 = load i8, ptr %.elt64, align 4, !tbaa !8
  %.elt66 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack67 = load i8, ptr %.elt66, align 1, !tbaa !8
  %.elt68 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack69 = load i8, ptr %.elt68, align 2, !tbaa !8
  %.elt70 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack71 = load i8, ptr %.elt70, align 1, !tbaa !8
  %.elt72 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack73.unpack.unpack = load i64, ptr %.elt72, align 8, !tbaa !8
  %.unpack73.unpack.elt75 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack73.unpack.elt75, align 8, !tbaa !8
  %.unpack73.unpack.elt77 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack73.unpack.elt77, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %27 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %28 = load i64, ptr %27, align 8, !tbaa !8
  %29 = load ptr, ptr %loadgep_6, align 8, !tbaa !8
  %30 = sub i64 %24, %28
  %31 = getelementptr double, ptr %29, i64 %30
  %32 = load double, ptr %31, align 8, !tbaa !4
  store double %32, ptr %loadgep_8, align 8, !tbaa !4
  %33 = add i32 %14, 1
  %34 = add nsw i64 %15, -1
  br label %omp.par.region5
}
*** IR Dump After ArgumentPromotionPass on (_QFPomp_subroutine..omp_par) ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub nsw i64 %11, %10
  %13 = add nsw i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %33, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %34, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = load ptr, ptr %loadgep_4, align 8, !tbaa !8
  %24 = sext i32 %14 to i64
  %25 = sub i64 %24, %22
  %26 = getelementptr double, ptr %23, i64 %25
  store double %20, ptr %26, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt60 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack61 = load i64, ptr %.elt60, align 8, !tbaa !8
  %.elt62 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack63 = load i32, ptr %.elt62, align 8, !tbaa !8
  %.elt64 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack65 = load i8, ptr %.elt64, align 4, !tbaa !8
  %.elt66 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack67 = load i8, ptr %.elt66, align 1, !tbaa !8
  %.elt68 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack69 = load i8, ptr %.elt68, align 2, !tbaa !8
  %.elt70 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack71 = load i8, ptr %.elt70, align 1, !tbaa !8
  %.elt72 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack73.unpack.unpack = load i64, ptr %.elt72, align 8, !tbaa !8
  %.unpack73.unpack.elt75 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack73.unpack.elt75, align 8, !tbaa !8
  %.unpack73.unpack.elt77 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack73.unpack.elt77, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %27 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %28 = load i64, ptr %27, align 8, !tbaa !8
  %29 = load ptr, ptr %loadgep_6, align 8, !tbaa !8
  %30 = sub i64 %24, %28
  %31 = getelementptr double, ptr %29, i64 %30
  %32 = load double, ptr %31, align 8, !tbaa !4
  store double %32, ptr %loadgep_8, align 8, !tbaa !4
  %33 = add i32 %14, 1
  %34 = add nsw i64 %15, -1
  br label %omp.par.region5
}
*** IR Dump After OpenMPOptCGSCCPass on (_QFPomp_subroutine..omp_par) ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub nsw i64 %11, %10
  %13 = add nsw i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %33, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %34, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = load ptr, ptr %loadgep_4, align 8, !tbaa !8
  %24 = sext i32 %14 to i64
  %25 = sub i64 %24, %22
  %26 = getelementptr double, ptr %23, i64 %25
  store double %20, ptr %26, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt60 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack61 = load i64, ptr %.elt60, align 8, !tbaa !8
  %.elt62 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack63 = load i32, ptr %.elt62, align 8, !tbaa !8
  %.elt64 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack65 = load i8, ptr %.elt64, align 4, !tbaa !8
  %.elt66 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack67 = load i8, ptr %.elt66, align 1, !tbaa !8
  %.elt68 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack69 = load i8, ptr %.elt68, align 2, !tbaa !8
  %.elt70 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack71 = load i8, ptr %.elt70, align 1, !tbaa !8
  %.elt72 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack73.unpack.unpack = load i64, ptr %.elt72, align 8, !tbaa !8
  %.unpack73.unpack.elt75 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack73.unpack.elt75, align 8, !tbaa !8
  %.unpack73.unpack.elt77 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack73.unpack.elt77, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %27 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %28 = load i64, ptr %27, align 8, !tbaa !8
  %29 = load ptr, ptr %loadgep_6, align 8, !tbaa !8
  %30 = sub i64 %24, %28
  %31 = getelementptr double, ptr %29, i64 %30
  %32 = load double, ptr %31, align 8, !tbaa !4
  store double %32, ptr %loadgep_8, align 8, !tbaa !4
  %33 = add i32 %14, 1
  %34 = add nsw i64 %15, -1
  br label %omp.par.region5
}
*** IR Dump After SROAPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub nsw i64 %11, %10
  %13 = add nsw i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %33, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %34, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = load ptr, ptr %loadgep_4, align 8, !tbaa !8
  %24 = sext i32 %14 to i64
  %25 = sub i64 %24, %22
  %26 = getelementptr double, ptr %23, i64 %25
  store double %20, ptr %26, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt60 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack61 = load i64, ptr %.elt60, align 8, !tbaa !8
  %.elt62 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack63 = load i32, ptr %.elt62, align 8, !tbaa !8
  %.elt64 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack65 = load i8, ptr %.elt64, align 4, !tbaa !8
  %.elt66 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack67 = load i8, ptr %.elt66, align 1, !tbaa !8
  %.elt68 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack69 = load i8, ptr %.elt68, align 2, !tbaa !8
  %.elt70 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack71 = load i8, ptr %.elt70, align 1, !tbaa !8
  %.elt72 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack73.unpack.unpack = load i64, ptr %.elt72, align 8, !tbaa !8
  %.unpack73.unpack.elt75 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack73.unpack.elt75, align 8, !tbaa !8
  %.unpack73.unpack.elt77 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack73.unpack.elt77, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %27 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %28 = load i64, ptr %27, align 8, !tbaa !8
  %29 = load ptr, ptr %loadgep_6, align 8, !tbaa !8
  %30 = sub i64 %24, %28
  %31 = getelementptr double, ptr %29, i64 %30
  %32 = load double, ptr %31, align 8, !tbaa !4
  store double %32, ptr %loadgep_8, align 8, !tbaa !4
  %33 = add i32 %14, 1
  %34 = add nsw i64 %15, -1
  br label %omp.par.region5
}
*** IR Dump After EarlyCSEPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub nsw i64 %11, %10
  %13 = add nsw i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %31, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %32, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = sext i32 %14 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %20, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %27 = load i64, ptr %26, align 8, !tbaa !8
  %28 = sub i64 %23, %27
  %29 = getelementptr double, ptr %.unpack59, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !4
  store double %30, ptr %loadgep_8, align 8, !tbaa !4
  %31 = add i32 %14, 1
  %32 = add nsw i64 %15, -1
  br label %omp.par.region5
}
*** IR Dump After SpeculativeExecutionPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub nsw i64 %11, %10
  %13 = add nsw i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %31, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %32, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = sext i32 %14 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %20, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %27 = load i64, ptr %26, align 8, !tbaa !8
  %28 = sub i64 %23, %27
  %29 = getelementptr double, ptr %.unpack59, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !4
  store double %30, ptr %loadgep_8, align 8, !tbaa !4
  %31 = add i32 %14, 1
  %32 = add nsw i64 %15, -1
  br label %omp.par.region5
}
*** IR Dump After JumpThreadingPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub nsw i64 %11, %10
  %13 = add nsw i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %31, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %32, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = sext i32 %14 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %20, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %27 = load i64, ptr %26, align 8, !tbaa !8
  %28 = sub i64 %23, %27
  %29 = getelementptr double, ptr %.unpack59, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !4
  store double %30, ptr %loadgep_8, align 8, !tbaa !4
  %31 = add i32 %14, 1
  %32 = add nsw i64 %15, -1
  br label %omp.par.region5
}
*** IR Dump After CorrelatedValuePropagationPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub nsw i64 %11, %10
  %13 = add nsw i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %31, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %32, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = sext i32 %14 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %20, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %27 = load i64, ptr %26, align 8, !tbaa !8
  %28 = sub i64 %23, %27
  %29 = getelementptr double, ptr %.unpack59, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !4
  store double %30, ptr %loadgep_8, align 8, !tbaa !4
  %31 = add i32 %14, 1
  %32 = add nsw i64 %15, -1
  br label %omp.par.region5
}
*** IR Dump After SimplifyCFGPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub nsw i64 %11, %10
  %13 = add nsw i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %31, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %32, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = sext i32 %14 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %20, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %27 = load i64, ptr %26, align 8, !tbaa !8
  %28 = sub i64 %23, %27
  %29 = getelementptr double, ptr %.unpack59, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !4
  store double %30, ptr %loadgep_8, align 8, !tbaa !4
  %31 = add i32 %14, 1
  %32 = add nsw i64 %15, -1
  br label %omp.par.region5
}
*** IR Dump After InstCombinePass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub nsw i64 %11, %10
  %13 = add nsw i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %31, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %32, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = sext i32 %14 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %20, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %27 = load i64, ptr %26, align 8, !tbaa !8
  %28 = sub i64 %23, %27
  %29 = getelementptr double, ptr %.unpack59, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !4
  store double %30, ptr %loadgep_8, align 8, !tbaa !4
  %31 = add i32 %14, 1
  %32 = add nsw i64 %15, -1
  br label %omp.par.region5
}
*** IR Dump After AggressiveInstCombinePass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub nsw i64 %11, %10
  %13 = add nsw i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %31, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %32, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = sext i32 %14 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %20, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %27 = load i64, ptr %26, align 8, !tbaa !8
  %28 = sub i64 %23, %27
  %29 = getelementptr double, ptr %.unpack59, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !4
  store double %30, ptr %loadgep_8, align 8, !tbaa !4
  %31 = add i32 %14, 1
  %32 = add nsw i64 %15, -1
  br label %omp.par.region5
}
*** IR Dump After ConstraintEliminationPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub nsw i64 %11, %10
  %13 = add nsw i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %31, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %32, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = sext i32 %14 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %20, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %27 = load i64, ptr %26, align 8, !tbaa !8
  %28 = sub i64 %23, %27
  %29 = getelementptr double, ptr %.unpack59, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !4
  store double %30, ptr %loadgep_8, align 8, !tbaa !4
  %31 = add i32 %14, 1
  %32 = add nsw i64 %15, -1
  br label %omp.par.region5
}
*** IR Dump After LibCallsShrinkWrapPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = call i32 @omp_get_thread_num()
  %2 = call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub nsw i64 %11, %10
  %13 = add nsw i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %31, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %32, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = sext i32 %14 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %20, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %27 = load i64, ptr %26, align 8, !tbaa !8
  %28 = sub i64 %23, %27
  %29 = getelementptr double, ptr %.unpack59, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !4
  store double %30, ptr %loadgep_8, align 8, !tbaa !4
  %31 = add i32 %14, 1
  %32 = add nsw i64 %15, -1
  br label %omp.par.region5
}
*** IR Dump After TailCallElimPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub nsw i64 %11, %10
  %13 = add nsw i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %31, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %32, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = sext i32 %14 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %20, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %27 = load i64, ptr %26, align 8, !tbaa !8
  %28 = sub i64 %23, %27
  %29 = getelementptr double, ptr %.unpack59, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !4
  store double %30, ptr %loadgep_8, align 8, !tbaa !4
  %31 = add i32 %14, 1
  %32 = add nsw i64 %15, -1
  br label %omp.par.region5
}
*** IR Dump After SimplifyCFGPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %1, %4
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %12 = sub nsw i64 %11, %10
  %13 = add nsw i64 %12, 1
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %31, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %32, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = sext i32 %14 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %20, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %27 = load i64, ptr %26, align 8, !tbaa !8
  %28 = sub i64 %23, %27
  %29 = getelementptr double, ptr %.unpack59, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !4
  store double %30, ptr %loadgep_8, align 8, !tbaa !4
  %31 = add i32 %14, 1
  %32 = add nsw i64 %15, -1
  br label %omp.par.region5
}
*** IR Dump After ReassociatePass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %.neg = sub i64 0, %10
  %12 = add i64 %.neg, 1
  %13 = add i64 %12, %11
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %31, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %32, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = sext i32 %14 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %20, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %27 = load i64, ptr %26, align 8, !tbaa !8
  %28 = sub i64 %23, %27
  %29 = getelementptr double, ptr %.unpack59, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !4
  store double %30, ptr %loadgep_8, align 8, !tbaa !4
  %31 = add i32 %14, 1
  %32 = add nsw i64 %15, -1
  br label %omp.par.region5
}
*** IR Dump After LoopSimplifyPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %.neg = sub i64 0, %10
  %12 = add i64 %.neg, 1
  %13 = add i64 %12, %11
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %31, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %32, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = sext i32 %14 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %20, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %27 = load i64, ptr %26, align 8, !tbaa !8
  %28 = sub i64 %23, %27
  %29 = getelementptr double, ptr %.unpack59, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !4
  store double %30, ptr %loadgep_8, align 8, !tbaa !4
  %31 = add i32 %14, 1
  %32 = add nsw i64 %15, -1
  br label %omp.par.region5
}
*** IR Dump After LCSSAPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %.neg = sub i64 0, %10
  %12 = add i64 %.neg, 1
  %13 = add i64 %12, %11
  br label %omp.par.region5

omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %31, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %32, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region5
  ret void

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = sext i32 %14 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %20, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %27 = load i64, ptr %26, align 8, !tbaa !8
  %28 = sub i64 %23, %27
  %29 = getelementptr double, ptr %.unpack59, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !4
  store double %30, ptr %loadgep_8, align 8, !tbaa !4
  %31 = add i32 %14, 1
  %32 = add nsw i64 %15, -1
  br label %omp.par.region5
}
*** IR Dump After LoopInstSimplifyPass on omp.par.region5 ***

; Preheader:
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %.neg = sub i64 0, %10
  %12 = add i64 %.neg, 1
  %13 = add i64 %12, %11
  br label %omp.par.region5

; Loop:
omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %31, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %32, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = sext i32 %14 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %20, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %27 = load i64, ptr %26, align 8, !tbaa !8
  %28 = sub i64 %23, %27
  %29 = getelementptr double, ptr %.unpack59, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !4
  store double %30, ptr %loadgep_8, align 8, !tbaa !4
  %31 = add i32 %14, 1
  %32 = add nsw i64 %15, -1
  br label %omp.par.region5

; Exit blocks
omp.par.region7:                                  ; preds = %omp.par.region5
  ret void
*** IR Dump After LoopSimplifyCFGPass on omp.par.region5 ***

; Preheader:
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %.neg = sub i64 0, %10
  %12 = add i64 %.neg, 1
  %13 = add i64 %12, %11
  br label %omp.par.region5

; Loop:
omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %31, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %32, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = sext i32 %14 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %20, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %27 = load i64, ptr %26, align 8, !tbaa !8
  %28 = sub i64 %23, %27
  %29 = getelementptr double, ptr %.unpack59, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !4
  store double %30, ptr %loadgep_8, align 8, !tbaa !4
  %31 = add i32 %14, 1
  %32 = add nsw i64 %15, -1
  br label %omp.par.region5

; Exit blocks
omp.par.region7:                                  ; preds = %omp.par.region5
  ret void
*** IR Dump After LICMPass on omp.par.region5 ***

; Preheader:
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %.neg = sub i64 0, %10
  %12 = add i64 %.neg, 1
  %13 = add i64 %12, %11
  br label %omp.par.region5

; Loop:
omp.par.region5:                                  ; preds = %omp.par.region6, %omp.par.entry
  %14 = phi i32 [ %31, %omp.par.region6 ], [ %6, %omp.par.entry ]
  %15 = phi i64 [ %32, %omp.par.region6 ], [ %13, %omp.par.entry ]
  %16 = icmp sgt i64 %15, 0
  br i1 %16, label %omp.par.region6, label %omp.par.region7

omp.par.region6:                                  ; preds = %omp.par.region5
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = sext i32 %14 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %20, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %27 = load i64, ptr %26, align 8, !tbaa !8
  %28 = sub i64 %23, %27
  %29 = getelementptr double, ptr %.unpack59, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !4
  store double %30, ptr %loadgep_8, align 8, !tbaa !4
  %31 = add i32 %14, 1
  %32 = add nsw i64 %15, -1
  br label %omp.par.region5

; Exit blocks
omp.par.region7:                                  ; preds = %omp.par.region5
  ret void
*** IR Dump After LoopRotatePass on omp.par.region5 ***

; Preheader:
omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  br label %omp.par.region6

; Loop:
omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %15 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %32, %omp.par.region6 ]
  %16 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %31, %omp.par.region6 ]
  %17 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %18 = sitofp i32 %17 to float
  %19 = fdiv contract float 1.000000e+00, %18
  %20 = fpext float %19 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %21 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %22 = load i64, ptr %21, align 8, !tbaa !8
  %23 = sext i32 %16 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %20, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  %27 = load i64, ptr %26, align 8, !tbaa !8
  %28 = sub i64 %23, %27
  %29 = getelementptr double, ptr %.unpack59, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !4
  store double %30, ptr %loadgep_8, align 8, !tbaa !4
  %31 = add i32 %16, 1
  %32 = add nsw i64 %15, -1
  %33 = icmp sgt i64 %32, 0
  br i1 %33, label %omp.par.region6, label %omp.par.region5.omp.par.region7_crit_edge

; Exit blocks
omp.par.region5.omp.par.region7_crit_edge:        ; preds = %omp.par.region6
  br label %omp.par.region7
*** IR Dump After LICMPass on omp.par.region6 ***

; Preheader:
omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %15 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  %16 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  br label %omp.par.region6

; Loop:
omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %17 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %32, %omp.par.region6 ]
  %18 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %31, %omp.par.region6 ]
  %19 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %20 = sitofp i32 %19 to float
  %21 = fdiv contract float 1.000000e+00, %20
  %22 = fpext float %21 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %23 = load i64, ptr %15, align 8, !tbaa !8
  %24 = sext i32 %18 to i64
  %25 = sub i64 %24, %23
  %26 = getelementptr double, ptr %.unpack, i64 %25
  store double %22, ptr %26, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %27 = load i64, ptr %16, align 8, !tbaa !8
  %28 = sub i64 %24, %27
  %29 = getelementptr double, ptr %.unpack59, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !4
  store double %30, ptr %loadgep_8, align 8, !tbaa !4
  %31 = add i32 %18, 1
  %32 = add nsw i64 %17, -1
  %33 = icmp sgt i64 %32, 0
  br i1 %33, label %omp.par.region6, label %omp.par.region5.omp.par.region7_crit_edge

; Exit blocks
omp.par.region5.omp.par.region7_crit_edge:        ; preds = %omp.par.region6
  br label %omp.par.region7
*** IR Dump After SimpleLoopUnswitchPass on omp.par.region6 ***

; Preheader:
omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %15 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  %16 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  br label %omp.par.region6

; Loop:
omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %17 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %32, %omp.par.region6 ]
  %18 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %31, %omp.par.region6 ]
  %19 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %20 = sitofp i32 %19 to float
  %21 = fdiv contract float 1.000000e+00, %20
  %22 = fpext float %21 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %23 = load i64, ptr %15, align 8, !tbaa !8
  %24 = sext i32 %18 to i64
  %25 = sub i64 %24, %23
  %26 = getelementptr double, ptr %.unpack, i64 %25
  store double %22, ptr %26, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %27 = load i64, ptr %16, align 8, !tbaa !8
  %28 = sub i64 %24, %27
  %29 = getelementptr double, ptr %.unpack59, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !4
  store double %30, ptr %loadgep_8, align 8, !tbaa !4
  %31 = add i32 %18, 1
  %32 = add nsw i64 %17, -1
  %33 = icmp sgt i64 %32, 0
  br i1 %33, label %omp.par.region6, label %omp.par.region5.omp.par.region7_crit_edge

; Exit blocks
omp.par.region5.omp.par.region7_crit_edge:        ; preds = %omp.par.region6
  br label %omp.par.region7
*** IR Dump After SimplifyCFGPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %.neg = sub i64 0, %10
  %12 = add i64 %.neg, 1
  %13 = add i64 %12, %11
  %14 = icmp sgt i64 %13, 0
  br i1 %14, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %15 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  %16 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %17 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %32, %omp.par.region6 ]
  %18 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %31, %omp.par.region6 ]
  %19 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %20 = sitofp i32 %19 to float
  %21 = fdiv contract float 1.000000e+00, %20
  %22 = fpext float %21 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %23 = load i64, ptr %15, align 8, !tbaa !8
  %24 = sext i32 %18 to i64
  %25 = sub i64 %24, %23
  %26 = getelementptr double, ptr %.unpack, i64 %25
  store double %22, ptr %26, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %27 = load i64, ptr %16, align 8, !tbaa !8
  %28 = sub i64 %24, %27
  %29 = getelementptr double, ptr %.unpack59, i64 %28
  %30 = load double, ptr %29, align 8, !tbaa !4
  store double %30, ptr %loadgep_8, align 8, !tbaa !4
  %31 = add i32 %18, 1
  %32 = add nsw i64 %17, -1
  %33 = icmp sgt i64 %32, 0
  br i1 %33, label %omp.par.region6, label %omp.par.region7
}
*** IR Dump After InstCombinePass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %14 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  %15 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %16 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %31, %omp.par.region6 ]
  %17 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %30, %omp.par.region6 ]
  %18 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %19 = sitofp i32 %18 to float
  %20 = fdiv contract float 1.000000e+00, %19
  %21 = fpext float %20 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %22 = load i64, ptr %14, align 8, !tbaa !8
  %23 = sext i32 %17 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %21, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = load i64, ptr %15, align 8, !tbaa !8
  %27 = sub i64 %23, %26
  %28 = getelementptr double, ptr %.unpack59, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !4
  store double %29, ptr %loadgep_8, align 8, !tbaa !4
  %30 = add i32 %17, 1
  %31 = add nsw i64 %16, -1
  %32 = icmp sgt i64 %16, 1
  br i1 %32, label %omp.par.region6, label %omp.par.region7
}
*** IR Dump After LoopSimplifyPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %14 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  %15 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %16 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %31, %omp.par.region6 ]
  %17 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %30, %omp.par.region6 ]
  %18 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %19 = sitofp i32 %18 to float
  %20 = fdiv contract float 1.000000e+00, %19
  %21 = fpext float %20 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %22 = load i64, ptr %14, align 8, !tbaa !8
  %23 = sext i32 %17 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %21, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = load i64, ptr %15, align 8, !tbaa !8
  %27 = sub i64 %23, %26
  %28 = getelementptr double, ptr %.unpack59, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !4
  store double %29, ptr %loadgep_8, align 8, !tbaa !4
  %30 = add i32 %17, 1
  %31 = add nsw i64 %16, -1
  %32 = icmp sgt i64 %16, 1
  br i1 %32, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After LCSSAPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %14 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  %15 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %16 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %31, %omp.par.region6 ]
  %17 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %30, %omp.par.region6 ]
  %18 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %19 = sitofp i32 %18 to float
  %20 = fdiv contract float 1.000000e+00, %19
  %21 = fpext float %20 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %22 = load i64, ptr %14, align 8, !tbaa !8
  %23 = sext i32 %17 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %21, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = load i64, ptr %15, align 8, !tbaa !8
  %27 = sub i64 %23, %26
  %28 = getelementptr double, ptr %.unpack59, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !4
  store double %29, ptr %loadgep_8, align 8, !tbaa !4
  %30 = add i32 %17, 1
  %31 = add nsw i64 %16, -1
  %32 = icmp sgt i64 %16, 1
  br i1 %32, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After LoopIdiomRecognizePass on omp.par.region6 ***

; Preheader:
omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %14 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  %15 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  br label %omp.par.region6

; Loop:
omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %16 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %31, %omp.par.region6 ]
  %17 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %30, %omp.par.region6 ]
  %18 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %19 = sitofp i32 %18 to float
  %20 = fdiv contract float 1.000000e+00, %19
  %21 = fpext float %20 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %22 = load i64, ptr %14, align 8, !tbaa !8
  %23 = sext i32 %17 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %21, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = load i64, ptr %15, align 8, !tbaa !8
  %27 = sub i64 %23, %26
  %28 = getelementptr double, ptr %.unpack59, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !4
  store double %29, ptr %loadgep_8, align 8, !tbaa !4
  %30 = add i32 %17, 1
  %31 = add nsw i64 %16, -1
  %32 = icmp sgt i64 %16, 1
  br i1 %32, label %omp.par.region6, label %omp.par.region7.loopexit

; Exit blocks
omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7
*** IR Dump After IndVarSimplifyPass on omp.par.region6 ***

; Preheader:
omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %14 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  %15 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  br label %omp.par.region6

; Loop:
omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %16 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %31, %omp.par.region6 ]
  %17 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %30, %omp.par.region6 ]
  %18 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %19 = sitofp i32 %18 to float
  %20 = fdiv contract float 1.000000e+00, %19
  %21 = fpext float %20 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %22 = load i64, ptr %14, align 8, !tbaa !8
  %23 = sext i32 %17 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %21, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = load i64, ptr %15, align 8, !tbaa !8
  %27 = sub i64 %23, %26
  %28 = getelementptr double, ptr %.unpack59, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !4
  store double %29, ptr %loadgep_8, align 8, !tbaa !4
  %30 = add i32 %17, 1
  %31 = add nsw i64 %16, -1
  %32 = icmp sgt i64 %16, 1
  br i1 %32, label %omp.par.region6, label %omp.par.region7.loopexit

; Exit blocks
omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7
*** IR Dump After LoopDeletionPass on omp.par.region6 ***

; Preheader:
omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %14 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  %15 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  br label %omp.par.region6

; Loop:
omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %16 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %31, %omp.par.region6 ]
  %17 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %30, %omp.par.region6 ]
  %18 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %19 = sitofp i32 %18 to float
  %20 = fdiv contract float 1.000000e+00, %19
  %21 = fpext float %20 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %22 = load i64, ptr %14, align 8, !tbaa !8
  %23 = sext i32 %17 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %21, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = load i64, ptr %15, align 8, !tbaa !8
  %27 = sub i64 %23, %26
  %28 = getelementptr double, ptr %.unpack59, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !4
  store double %29, ptr %loadgep_8, align 8, !tbaa !4
  %30 = add i32 %17, 1
  %31 = add nsw i64 %16, -1
  %32 = icmp sgt i64 %16, 1
  br i1 %32, label %omp.par.region6, label %omp.par.region7.loopexit

; Exit blocks
omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7
*** IR Dump After LoopFullUnrollPass on omp.par.region6 ***

; Preheader:
omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %14 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  %15 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  br label %omp.par.region6

; Loop:
omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %16 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %31, %omp.par.region6 ]
  %17 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %30, %omp.par.region6 ]
  %18 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %19 = sitofp i32 %18 to float
  %20 = fdiv contract float 1.000000e+00, %19
  %21 = fpext float %20 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %22 = load i64, ptr %14, align 8, !tbaa !8
  %23 = sext i32 %17 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %21, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = load i64, ptr %15, align 8, !tbaa !8
  %27 = sub i64 %23, %26
  %28 = getelementptr double, ptr %.unpack59, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !4
  store double %29, ptr %loadgep_8, align 8, !tbaa !4
  %30 = add i32 %17, 1
  %31 = add nsw i64 %16, -1
  %32 = icmp sgt i64 %16, 1
  br i1 %32, label %omp.par.region6, label %omp.par.region7.loopexit

; Exit blocks
omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7
*** IR Dump After SROAPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %14 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  %15 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %16 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %31, %omp.par.region6 ]
  %17 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %30, %omp.par.region6 ]
  %18 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %19 = sitofp i32 %18 to float
  %20 = fdiv contract float 1.000000e+00, %19
  %21 = fpext float %20 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %22 = load i64, ptr %14, align 8, !tbaa !8
  %23 = sext i32 %17 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %21, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = load i64, ptr %15, align 8, !tbaa !8
  %27 = sub i64 %23, %26
  %28 = getelementptr double, ptr %.unpack59, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !4
  store double %29, ptr %loadgep_8, align 8, !tbaa !4
  %30 = add i32 %17, 1
  %31 = add nsw i64 %16, -1
  %32 = icmp sgt i64 %16, 1
  br i1 %32, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After VectorCombinePass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %14 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  %15 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %16 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %31, %omp.par.region6 ]
  %17 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %30, %omp.par.region6 ]
  %18 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %19 = sitofp i32 %18 to float
  %20 = fdiv contract float 1.000000e+00, %19
  %21 = fpext float %20 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %22 = load i64, ptr %14, align 8, !tbaa !8
  %23 = sext i32 %17 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %21, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = load i64, ptr %15, align 8, !tbaa !8
  %27 = sub i64 %23, %26
  %28 = getelementptr double, ptr %.unpack59, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !4
  store double %29, ptr %loadgep_8, align 8, !tbaa !4
  %30 = add i32 %17, 1
  %31 = add nsw i64 %16, -1
  %32 = icmp sgt i64 %16, 1
  br i1 %32, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After MergedLoadStoreMotionPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %14 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 0
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  %15 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 0
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %16 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %31, %omp.par.region6 ]
  %17 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %30, %omp.par.region6 ]
  %18 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %19 = sitofp i32 %18 to float
  %20 = fdiv contract float 1.000000e+00, %19
  %21 = fpext float %20 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %22 = load i64, ptr %14, align 8, !tbaa !8
  %23 = sext i32 %17 to i64
  %24 = sub i64 %23, %22
  %25 = getelementptr double, ptr %.unpack, i64 %24
  store double %21, ptr %25, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %26 = load i64, ptr %15, align 8, !tbaa !8
  %27 = sub i64 %23, %26
  %28 = getelementptr double, ptr %.unpack59, i64 %27
  %29 = load double, ptr %28, align 8, !tbaa !4
  store double %29, ptr %loadgep_8, align 8, !tbaa !4
  %30 = add i32 %17, 1
  %31 = add nsw i64 %16, -1
  %32 = icmp sgt i64 %16, 1
  br i1 %32, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After GVNPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp sgt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After SCCPPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp sgt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After BDCEPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp sgt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After InstCombinePass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp sgt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After JumpThreadingPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp sgt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}
*** IR Dump After CorrelatedValuePropagationPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}
*** IR Dump After ADCEPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}
*** IR Dump After MemCpyOptPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}
*** IR Dump After DSEPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}
*** IR Dump After MoveAutoInitPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}
*** IR Dump After LoopSimplifyPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After LCSSAPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After LICMPass on omp.par.region6 ***

; Preheader:
omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

; Loop:
omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit

; Exit blocks
omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7
*** IR Dump After CoroElidePass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After SimplifyCFGPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}
*** IR Dump After InstCombinePass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias %tid.addr, ptr noalias %zero.addr, ptr %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}
*** IR Dump After PostOrderFunctionAttrsPass on (_QFPomp_subroutine..omp_par) ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}
*** IR Dump After RequireAnalysisPass<llvm::ShouldNotRunFunctionPassesAnalysis, llvm::Function> on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}
*** IR Dump After CoroSplitPass on (_QFPomp_subroutine..omp_par) ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #2 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}
*** IR Dump After InlinerPass on (_QFPomp_subroutine) ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !4
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !4
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !4
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !4
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !4
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !4
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !4
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !4
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !4
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !8
  %7 = call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !4
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !4
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !4
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !4
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !4
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !4
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !4
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !4
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !4
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !4
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !4
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !8
  %14 = load i32, ptr %0, align 4, !tbaa !8
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !8
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !8
  %.fca.0.load43 = load ptr, ptr %4, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load43)
  store ptr null, ptr %4, align 8, !tbaa !4
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !4
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !4
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !4
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !4
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !4
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !4
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !4
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !4
  ret void
}
*** IR Dump After InlinerPass on (_QFPomp_subroutine) ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !4
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !4
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !4
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !4
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !4
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !4
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !4
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !4
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !4
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !8
  %7 = call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !4
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !4
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !4
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !4
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !4
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !4
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !4
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !4
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !4
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !4
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !4
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !8
  %14 = load i32, ptr %0, align 4, !tbaa !8
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !8
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !8
  %.fca.0.load43 = load ptr, ptr %4, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load43)
  store ptr null, ptr %4, align 8, !tbaa !4
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !4
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !4
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !4
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !4
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !4
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !4
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !4
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !4
  ret void
}
*** IR Dump After PostOrderFunctionAttrsPass on (_QFPomp_subroutine) ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !4
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !4
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !4
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !4
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !4
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !4
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !4
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !4
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !4
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !8
  %7 = call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !4
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !4
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !4
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !4
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !4
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !4
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !4
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !4
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !4
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !4
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !4
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !8
  %14 = load i32, ptr %0, align 4, !tbaa !8
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !8
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !8
  %.fca.0.load43 = load ptr, ptr %4, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load43)
  store ptr null, ptr %4, align 8, !tbaa !4
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !4
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !4
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !4
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !4
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !4
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !4
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !4
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !4
  ret void
}
*** IR Dump After ArgumentPromotionPass on (_QFPomp_subroutine) ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !4
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !4
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !4
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !4
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !4
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !4
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !4
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !4
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !4
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !8
  %7 = call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !4
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !4
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !4
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !4
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !4
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !4
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !4
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !4
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !4
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !4
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !4
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !8
  %14 = load i32, ptr %0, align 4, !tbaa !8
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !8
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !8
  %.fca.0.load43 = load ptr, ptr %4, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load43)
  store ptr null, ptr %4, align 8, !tbaa !4
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !4
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !4
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !4
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !4
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !4
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !4
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !4
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !4
  ret void
}
*** IR Dump After OpenMPOptCGSCCPass on (_QFPomp_subroutine) ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !4
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !4
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !4
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !4
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !4
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !4
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !4
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !4
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !4
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !8
  %7 = call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !4
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !4
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !4
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !4
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !4
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !4
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !4
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !4
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !4
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !4
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !4
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !8
  %14 = load i32, ptr %0, align 4, !tbaa !8
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !8
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !8
  %.fca.0.load43 = load ptr, ptr %4, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load43)
  store ptr null, ptr %4, align 8, !tbaa !4
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !4
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !4
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !4
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !4
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !4
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !4
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !4
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !4
  ret void
}
*** IR Dump After SROAPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  %.fca.0.load43 = load ptr, ptr %4, align 8, !tbaa !8
  call void @free(ptr %.fca.0.load43)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After EarlyCSEPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After SpeculativeExecutionPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After JumpThreadingPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After CorrelatedValuePropagationPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After SimplifyCFGPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After InstCombinePass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After AggressiveInstCombinePass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After ConstraintEliminationPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After LibCallsShrinkWrapPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After TailCallElimPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After SimplifyCFGPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After ReassociatePass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After LoopSimplifyPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After LCSSAPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After SimplifyCFGPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After InstCombinePass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After LoopSimplifyPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After LCSSAPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After SROAPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After VectorCombinePass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After MergedLoadStoreMotionPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After GVNPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After SCCPPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After BDCEPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After InstCombinePass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After JumpThreadingPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After CorrelatedValuePropagationPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After ADCEPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After MemCpyOptPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  store ptr null, ptr %4, align 8, !tbaa !8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  store ptr null, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 0, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  ret void
}
*** IR Dump After DSEPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After MoveAutoInitPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After LoopSimplifyPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After LCSSAPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After CoroElidePass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After SimplifyCFGPass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After InstCombinePass on _QFPomp_subroutine ***
define void @_QFPomp_subroutine(ptr %0, ptr %1) local_unnamed_addr {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After PostOrderFunctionAttrsPass on (_QFPomp_subroutine) ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After RequireAnalysisPass<llvm::ShouldNotRunFunctionPassesAnalysis, llvm::Function> on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After CoroSplitPass on (_QFPomp_subroutine) ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After InlinerPass on (_QQmain) ***
define void @_QQmain() local_unnamed_addr {
  %1 = alloca i32, align 4
  %2 = alloca double, align 8
  store i32 1048576, ptr %1, align 4, !tbaa !4
  call void @_QFPomp_subroutine(ptr nonnull %1, ptr nonnull %2)
  %3 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %4 = call i1 @_FortranAioOutputAscii(ptr %3, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %5 = load i32, ptr %1, align 4, !tbaa !4
  %6 = call i1 @_FortranAioOutputInteger32(ptr %3, i32 %5)
  %7 = call i1 @_FortranAioOutputAscii(ptr %3, ptr nonnull @_QQcl.2920697320, i64 5)
  %8 = load double, ptr %2, align 8, !tbaa !4
  %9 = call i1 @_FortranAioOutputReal64(ptr %3, double %8)
  %10 = call i32 @_FortranAioEndIoStatement(ptr %3)
  ret void
}
*** IR Dump After InlinerPass on (_QQmain) ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  %6 = alloca double, align 8
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %7 = load i32, ptr %5, align 4, !tbaa !4
  %8 = call i32 @llvm.smax.i32(i32 %7, i32 0)
  %9 = zext i32 %8 to i64
  %10 = shl nuw nsw i64 %9, 3
  %11 = call ptr @malloc(i64 %10)
  store ptr %11, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 %9, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %12 = sub i64 1, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = load i32, ptr %5, align 4, !tbaa !4
  %16 = sext i32 %15 to i64
  %17 = sub i64 %16, %.fca.7.0.0.load.i
  %18 = getelementptr double, ptr %.fca.0.load.i, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !4
  %20 = fadd contract double %14, %19
  store double %20, ptr %6, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  %21 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %22 = call i1 @_FortranAioOutputAscii(ptr %21, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %23 = load i32, ptr %5, align 4, !tbaa !4
  %24 = call i1 @_FortranAioOutputInteger32(ptr %21, i32 %23)
  %25 = call i1 @_FortranAioOutputAscii(ptr %21, ptr nonnull @_QQcl.2920697320, i64 5)
  %26 = load double, ptr %6, align 8, !tbaa !4
  %27 = call i1 @_FortranAioOutputReal64(ptr %21, double %26)
  %28 = call i32 @_FortranAioEndIoStatement(ptr %21)
  ret void
}
*** IR Dump After PostOrderFunctionAttrsPass on (_QQmain) ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  %6 = alloca double, align 8
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %7 = load i32, ptr %5, align 4, !tbaa !4
  %8 = call i32 @llvm.smax.i32(i32 %7, i32 0)
  %9 = zext i32 %8 to i64
  %10 = shl nuw nsw i64 %9, 3
  %11 = call ptr @malloc(i64 %10)
  store ptr %11, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 %9, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %12 = sub i64 1, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = load i32, ptr %5, align 4, !tbaa !4
  %16 = sext i32 %15 to i64
  %17 = sub i64 %16, %.fca.7.0.0.load.i
  %18 = getelementptr double, ptr %.fca.0.load.i, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !4
  %20 = fadd contract double %14, %19
  store double %20, ptr %6, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  %21 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %22 = call i1 @_FortranAioOutputAscii(ptr %21, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %23 = load i32, ptr %5, align 4, !tbaa !4
  %24 = call i1 @_FortranAioOutputInteger32(ptr %21, i32 %23)
  %25 = call i1 @_FortranAioOutputAscii(ptr %21, ptr nonnull @_QQcl.2920697320, i64 5)
  %26 = load double, ptr %6, align 8, !tbaa !4
  %27 = call i1 @_FortranAioOutputReal64(ptr %21, double %26)
  %28 = call i32 @_FortranAioEndIoStatement(ptr %21)
  ret void
}
*** IR Dump After ArgumentPromotionPass on (_QQmain) ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  %6 = alloca double, align 8
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %7 = load i32, ptr %5, align 4, !tbaa !4
  %8 = call i32 @llvm.smax.i32(i32 %7, i32 0)
  %9 = zext i32 %8 to i64
  %10 = shl nuw nsw i64 %9, 3
  %11 = call ptr @malloc(i64 %10)
  store ptr %11, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 %9, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %12 = sub i64 1, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = load i32, ptr %5, align 4, !tbaa !4
  %16 = sext i32 %15 to i64
  %17 = sub i64 %16, %.fca.7.0.0.load.i
  %18 = getelementptr double, ptr %.fca.0.load.i, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !4
  %20 = fadd contract double %14, %19
  store double %20, ptr %6, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  %21 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %22 = call i1 @_FortranAioOutputAscii(ptr %21, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %23 = load i32, ptr %5, align 4, !tbaa !4
  %24 = call i1 @_FortranAioOutputInteger32(ptr %21, i32 %23)
  %25 = call i1 @_FortranAioOutputAscii(ptr %21, ptr nonnull @_QQcl.2920697320, i64 5)
  %26 = load double, ptr %6, align 8, !tbaa !4
  %27 = call i1 @_FortranAioOutputReal64(ptr %21, double %26)
  %28 = call i32 @_FortranAioEndIoStatement(ptr %21)
  ret void
}
*** IR Dump After OpenMPOptCGSCCPass on (_QQmain) ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  %6 = alloca double, align 8
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %7 = load i32, ptr %5, align 4, !tbaa !4
  %8 = call i32 @llvm.smax.i32(i32 %7, i32 0)
  %9 = zext i32 %8 to i64
  %10 = shl nuw nsw i64 %9, 3
  %11 = call ptr @malloc(i64 %10)
  store ptr %11, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 %9, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %12 = sub i64 1, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = load i32, ptr %5, align 4, !tbaa !4
  %16 = sext i32 %15 to i64
  %17 = sub i64 %16, %.fca.7.0.0.load.i
  %18 = getelementptr double, ptr %.fca.0.load.i, i64 %17
  %19 = load double, ptr %18, align 8, !tbaa !4
  %20 = fadd contract double %14, %19
  store double %20, ptr %6, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  %21 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %22 = call i1 @_FortranAioOutputAscii(ptr %21, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %23 = load i32, ptr %5, align 4, !tbaa !4
  %24 = call i1 @_FortranAioOutputInteger32(ptr %21, i32 %23)
  %25 = call i1 @_FortranAioOutputAscii(ptr %21, ptr nonnull @_QQcl.2920697320, i64 5)
  %26 = load double, ptr %6, align 8, !tbaa !4
  %27 = call i1 @_FortranAioOutputReal64(ptr %21, double %26)
  %28 = call i32 @_FortranAioEndIoStatement(ptr %21)
  ret void
}
*** IR Dump After SROAPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = load i32, ptr %5, align 4, !tbaa !4
  %7 = call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = call ptr @malloc(i64 %9)
  store ptr %10, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load.i
  %12 = getelementptr double, ptr %.fca.0.load.i, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %5, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load.i
  %17 = getelementptr double, ptr %.fca.0.load.i, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  %20 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %21 = call i1 @_FortranAioOutputAscii(ptr %20, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %22 = load i32, ptr %5, align 4, !tbaa !4
  %23 = call i1 @_FortranAioOutputInteger32(ptr %20, i32 %22)
  %24 = call i1 @_FortranAioOutputAscii(ptr %20, ptr nonnull @_QQcl.2920697320, i64 5)
  %25 = call i1 @_FortranAioOutputReal64(ptr %20, double %19)
  %26 = call i32 @_FortranAioEndIoStatement(ptr %20)
  ret void
}
*** IR Dump After EarlyCSEPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = call ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After SpeculativeExecutionPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = call ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After JumpThreadingPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = call ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After CorrelatedValuePropagationPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = call ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After SimplifyCFGPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = call ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After InstCombinePass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After AggressiveInstCombinePass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After ConstraintEliminationPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After LibCallsShrinkWrapPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After TailCallElimPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After SimplifyCFGPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After ReassociatePass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After LoopSimplifyPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After LCSSAPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After SimplifyCFGPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After InstCombinePass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After LoopSimplifyPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After LCSSAPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After SROAPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After VectorCombinePass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After MergedLoadStoreMotionPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After GVNPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After SCCPPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After BDCEPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After InstCombinePass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After JumpThreadingPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After CorrelatedValuePropagationPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After ADCEPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After MemCpyOptPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After DSEPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After MoveAutoInitPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After LoopSimplifyPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After LCSSAPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After CoroElidePass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After SimplifyCFGPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After InstCombinePass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After PostOrderFunctionAttrsPass on (_QQmain) ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After RequireAnalysisPass<llvm::ShouldNotRunFunctionPassesAnalysis, llvm::Function> on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After CoroSplitPass on (_QQmain) ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After InvalidateAnalysisPass<llvm::ShouldNotRunFunctionPassesAnalysis> on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After InvalidateAnalysisPass<llvm::ShouldNotRunFunctionPassesAnalysis> on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After InvalidateAnalysisPass<llvm::ShouldNotRunFunctionPassesAnalysis> on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}
*** IR Dump After DeadArgumentEliminationPass on [module] ***
; ModuleID = 'FIRModule'
source_filename = "FIRModule"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.ident_t = type { i32, i32, i32, i32, ptr }

@_QQcl.28612C69372C612C6531332E36653229 = internal constant [16 x i8] c"(a,i7,a,e13.6e2)"
@_QQcl.21557d42704c5c1f18a68415065290ee = internal constant [50 x i8] c"/g/g92/rydahl1/flangtests/src/parallel_region.f90\00"
@_QQcl.54686520726573756C74206F6620286172722831292B61727228 = internal constant [26 x i8] c"The result of (arr(1)+arr("
@_QQcl.2920697320 = internal constant [5 x i8] c") is "
@_QQEnvironmentDefaults = local_unnamed_addr constant ptr null
@0 = private unnamed_addr constant [23 x i8] c";unknown;unknown;0;0;;\00", align 1
@1 = private unnamed_addr constant %struct.ident_t { i32 0, i32 2, i32 0, i32 22, ptr @0 }, align 8

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite)
declare noalias noundef ptr @malloc(i64 noundef) local_unnamed_addr #0

; Function Attrs: mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite)
declare void @free(ptr allocptr nocapture noundef) local_unnamed_addr #1

define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}

; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}

; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}

declare ptr @_FortranAioBeginExternalFormattedOutput(ptr, i64, ptr, i32, ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputAscii(ptr, ptr, i64) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputInteger32(ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputReal64(ptr, double) local_unnamed_addr

declare i32 @_FortranAioEndIoStatement(ptr) local_unnamed_addr

; Function Attrs: nounwind
declare i32 @omp_get_thread_num() local_unnamed_addr #2

; Function Attrs: nounwind
declare i32 @omp_get_num_threads() local_unnamed_addr #2

; Function Attrs: nounwind
declare i32 @__kmpc_global_thread_num(ptr) local_unnamed_addr #2

; Function Attrs: nounwind
declare !callback !10 void @__kmpc_fork_call(ptr, i32, ptr, ...) local_unnamed_addr #2

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.smax.i64(i64, i64) #4

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #4

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #5

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #5

attributes #0 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #1 = { mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #2 = { nounwind }
attributes #3 = { norecurse nounwind }
attributes #4 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #5 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i32 7, !"openmp", i32 11}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{!5, !5, i64 0}
!5 = !{!"any data access", !6, i64 0}
!6 = !{!"any access", !7, i64 0}
!7 = !{!"Flang Type TBAA Root"}
!8 = !{!9, !9, i64 0}
!9 = !{!"descriptor member", !6, i64 0}
!10 = !{!11}
!11 = !{i64 2, i64 -1, i64 -1, i1 true}
*** IR Dump After CoroCleanupPass on [module] ***
; ModuleID = 'FIRModule'
source_filename = "FIRModule"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.ident_t = type { i32, i32, i32, i32, ptr }

@_QQcl.28612C69372C612C6531332E36653229 = internal constant [16 x i8] c"(a,i7,a,e13.6e2)"
@_QQcl.21557d42704c5c1f18a68415065290ee = internal constant [50 x i8] c"/g/g92/rydahl1/flangtests/src/parallel_region.f90\00"
@_QQcl.54686520726573756C74206F6620286172722831292B61727228 = internal constant [26 x i8] c"The result of (arr(1)+arr("
@_QQcl.2920697320 = internal constant [5 x i8] c") is "
@_QQEnvironmentDefaults = local_unnamed_addr constant ptr null
@0 = private unnamed_addr constant [23 x i8] c";unknown;unknown;0;0;;\00", align 1
@1 = private unnamed_addr constant %struct.ident_t { i32 0, i32 2, i32 0, i32 22, ptr @0 }, align 8

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite)
declare noalias noundef ptr @malloc(i64 noundef) local_unnamed_addr #0

; Function Attrs: mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite)
declare void @free(ptr allocptr nocapture noundef) local_unnamed_addr #1

define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}

; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}

; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}

declare ptr @_FortranAioBeginExternalFormattedOutput(ptr, i64, ptr, i32, ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputAscii(ptr, ptr, i64) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputInteger32(ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputReal64(ptr, double) local_unnamed_addr

declare i32 @_FortranAioEndIoStatement(ptr) local_unnamed_addr

; Function Attrs: nounwind
declare i32 @omp_get_thread_num() local_unnamed_addr #2

; Function Attrs: nounwind
declare i32 @omp_get_num_threads() local_unnamed_addr #2

; Function Attrs: nounwind
declare i32 @__kmpc_global_thread_num(ptr) local_unnamed_addr #2

; Function Attrs: nounwind
declare !callback !10 void @__kmpc_fork_call(ptr, i32, ptr, ...) local_unnamed_addr #2

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.smax.i64(i64, i64) #4

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #4

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #5

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #5

attributes #0 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #1 = { mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #2 = { nounwind }
attributes #3 = { norecurse nounwind }
attributes #4 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #5 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i32 7, !"openmp", i32 11}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{!5, !5, i64 0}
!5 = !{!"any data access", !6, i64 0}
!6 = !{!"any access", !7, i64 0}
!7 = !{!"Flang Type TBAA Root"}
!8 = !{!9, !9, i64 0}
!9 = !{!"descriptor member", !6, i64 0}
!10 = !{!11}
!11 = !{i64 2, i64 -1, i64 -1, i1 true}
*** IR Dump After GlobalOptPass on [module] ***
; ModuleID = 'FIRModule'
source_filename = "FIRModule"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.ident_t = type { i32, i32, i32, i32, ptr }

@_QQcl.28612C69372C612C6531332E36653229 = internal constant [16 x i8] c"(a,i7,a,e13.6e2)"
@_QQcl.21557d42704c5c1f18a68415065290ee = internal constant [50 x i8] c"/g/g92/rydahl1/flangtests/src/parallel_region.f90\00"
@_QQcl.54686520726573756C74206F6620286172722831292B61727228 = internal constant [26 x i8] c"The result of (arr(1)+arr("
@_QQcl.2920697320 = internal constant [5 x i8] c") is "
@_QQEnvironmentDefaults = local_unnamed_addr constant ptr null
@0 = private unnamed_addr constant [23 x i8] c";unknown;unknown;0;0;;\00", align 1
@1 = private unnamed_addr constant %struct.ident_t { i32 0, i32 2, i32 0, i32 22, ptr @0 }, align 8

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite)
declare noalias noundef ptr @malloc(i64 noundef) local_unnamed_addr #0

; Function Attrs: mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite)
declare void @free(ptr allocptr nocapture noundef) local_unnamed_addr #1

define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}

; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}

; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}

declare ptr @_FortranAioBeginExternalFormattedOutput(ptr, i64, ptr, i32, ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputAscii(ptr, ptr, i64) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputInteger32(ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputReal64(ptr, double) local_unnamed_addr

declare i32 @_FortranAioEndIoStatement(ptr) local_unnamed_addr

; Function Attrs: nounwind
declare i32 @omp_get_thread_num() local_unnamed_addr #2

; Function Attrs: nounwind
declare i32 @omp_get_num_threads() local_unnamed_addr #2

; Function Attrs: nounwind
declare i32 @__kmpc_global_thread_num(ptr) local_unnamed_addr #2

; Function Attrs: nounwind
declare !callback !10 void @__kmpc_fork_call(ptr, i32, ptr, ...) local_unnamed_addr #2

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #4

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #5

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #5

attributes #0 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #1 = { mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #2 = { nounwind }
attributes #3 = { norecurse nounwind }
attributes #4 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #5 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i32 7, !"openmp", i32 11}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{!5, !5, i64 0}
!5 = !{!"any data access", !6, i64 0}
!6 = !{!"any access", !7, i64 0}
!7 = !{!"Flang Type TBAA Root"}
!8 = !{!9, !9, i64 0}
!9 = !{!"descriptor member", !6, i64 0}
!10 = !{!11}
!11 = !{i64 2, i64 -1, i64 -1, i1 true}
*** IR Dump After GlobalDCEPass on [module] ***
; ModuleID = 'FIRModule'
source_filename = "FIRModule"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.ident_t = type { i32, i32, i32, i32, ptr }

@_QQcl.28612C69372C612C6531332E36653229 = internal constant [16 x i8] c"(a,i7,a,e13.6e2)"
@_QQcl.21557d42704c5c1f18a68415065290ee = internal constant [50 x i8] c"/g/g92/rydahl1/flangtests/src/parallel_region.f90\00"
@_QQcl.54686520726573756C74206F6620286172722831292B61727228 = internal constant [26 x i8] c"The result of (arr(1)+arr("
@_QQcl.2920697320 = internal constant [5 x i8] c") is "
@_QQEnvironmentDefaults = local_unnamed_addr constant ptr null
@0 = private unnamed_addr constant [23 x i8] c";unknown;unknown;0;0;;\00", align 1
@1 = private unnamed_addr constant %struct.ident_t { i32 0, i32 2, i32 0, i32 22, ptr @0 }, align 8

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite)
declare noalias noundef ptr @malloc(i64 noundef) local_unnamed_addr #0

; Function Attrs: mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite)
declare void @free(ptr allocptr nocapture noundef) local_unnamed_addr #1

define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}

; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}

; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}

declare ptr @_FortranAioBeginExternalFormattedOutput(ptr, i64, ptr, i32, ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputAscii(ptr, ptr, i64) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputInteger32(ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputReal64(ptr, double) local_unnamed_addr

declare i32 @_FortranAioEndIoStatement(ptr) local_unnamed_addr

; Function Attrs: nounwind
declare i32 @omp_get_thread_num() local_unnamed_addr #2

; Function Attrs: nounwind
declare i32 @omp_get_num_threads() local_unnamed_addr #2

; Function Attrs: nounwind
declare i32 @__kmpc_global_thread_num(ptr) local_unnamed_addr #2

; Function Attrs: nounwind
declare !callback !10 void @__kmpc_fork_call(ptr, i32, ptr, ...) local_unnamed_addr #2

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #4

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #5

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #5

attributes #0 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #1 = { mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #2 = { nounwind }
attributes #3 = { norecurse nounwind }
attributes #4 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #5 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i32 7, !"openmp", i32 11}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{!5, !5, i64 0}
!5 = !{!"any data access", !6, i64 0}
!6 = !{!"any access", !7, i64 0}
!7 = !{!"Flang Type TBAA Root"}
!8 = !{!9, !9, i64 0}
!9 = !{!"descriptor member", !6, i64 0}
!10 = !{!11}
!11 = !{i64 2, i64 -1, i64 -1, i1 true}
*** IR Dump After EliminateAvailableExternallyPass on [module] ***
; ModuleID = 'FIRModule'
source_filename = "FIRModule"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.ident_t = type { i32, i32, i32, i32, ptr }

@_QQcl.28612C69372C612C6531332E36653229 = internal constant [16 x i8] c"(a,i7,a,e13.6e2)"
@_QQcl.21557d42704c5c1f18a68415065290ee = internal constant [50 x i8] c"/g/g92/rydahl1/flangtests/src/parallel_region.f90\00"
@_QQcl.54686520726573756C74206F6620286172722831292B61727228 = internal constant [26 x i8] c"The result of (arr(1)+arr("
@_QQcl.2920697320 = internal constant [5 x i8] c") is "
@_QQEnvironmentDefaults = local_unnamed_addr constant ptr null
@0 = private unnamed_addr constant [23 x i8] c";unknown;unknown;0;0;;\00", align 1
@1 = private unnamed_addr constant %struct.ident_t { i32 0, i32 2, i32 0, i32 22, ptr @0 }, align 8

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite)
declare noalias noundef ptr @malloc(i64 noundef) local_unnamed_addr #0

; Function Attrs: mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite)
declare void @free(ptr allocptr nocapture noundef) local_unnamed_addr #1

define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}

; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}

; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}

declare ptr @_FortranAioBeginExternalFormattedOutput(ptr, i64, ptr, i32, ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputAscii(ptr, ptr, i64) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputInteger32(ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputReal64(ptr, double) local_unnamed_addr

declare i32 @_FortranAioEndIoStatement(ptr) local_unnamed_addr

; Function Attrs: nounwind
declare i32 @omp_get_thread_num() local_unnamed_addr #2

; Function Attrs: nounwind
declare i32 @omp_get_num_threads() local_unnamed_addr #2

; Function Attrs: nounwind
declare i32 @__kmpc_global_thread_num(ptr) local_unnamed_addr #2

; Function Attrs: nounwind
declare !callback !10 void @__kmpc_fork_call(ptr, i32, ptr, ...) local_unnamed_addr #2

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #4

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #5

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #5

attributes #0 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #1 = { mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #2 = { nounwind }
attributes #3 = { norecurse nounwind }
attributes #4 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #5 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i32 7, !"openmp", i32 11}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{!5, !5, i64 0}
!5 = !{!"any data access", !6, i64 0}
!6 = !{!"any access", !7, i64 0}
!7 = !{!"Flang Type TBAA Root"}
!8 = !{!9, !9, i64 0}
!9 = !{!"descriptor member", !6, i64 0}
!10 = !{!11}
!11 = !{i64 2, i64 -1, i64 -1, i1 true}
*** IR Dump After ReversePostOrderFunctionAttrsPass on [module] ***
; ModuleID = 'FIRModule'
source_filename = "FIRModule"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.ident_t = type { i32, i32, i32, i32, ptr }

@_QQcl.28612C69372C612C6531332E36653229 = internal constant [16 x i8] c"(a,i7,a,e13.6e2)"
@_QQcl.21557d42704c5c1f18a68415065290ee = internal constant [50 x i8] c"/g/g92/rydahl1/flangtests/src/parallel_region.f90\00"
@_QQcl.54686520726573756C74206F6620286172722831292B61727228 = internal constant [26 x i8] c"The result of (arr(1)+arr("
@_QQcl.2920697320 = internal constant [5 x i8] c") is "
@_QQEnvironmentDefaults = local_unnamed_addr constant ptr null
@0 = private unnamed_addr constant [23 x i8] c";unknown;unknown;0;0;;\00", align 1
@1 = private unnamed_addr constant %struct.ident_t { i32 0, i32 2, i32 0, i32 22, ptr @0 }, align 8

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite)
declare noalias noundef ptr @malloc(i64 noundef) local_unnamed_addr #0

; Function Attrs: mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite)
declare void @free(ptr allocptr nocapture noundef) local_unnamed_addr #1

define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}

; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}

; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}

declare ptr @_FortranAioBeginExternalFormattedOutput(ptr, i64, ptr, i32, ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputAscii(ptr, ptr, i64) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputInteger32(ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputReal64(ptr, double) local_unnamed_addr

declare i32 @_FortranAioEndIoStatement(ptr) local_unnamed_addr

; Function Attrs: nounwind
declare i32 @omp_get_thread_num() local_unnamed_addr #2

; Function Attrs: nounwind
declare i32 @omp_get_num_threads() local_unnamed_addr #2

; Function Attrs: nounwind
declare i32 @__kmpc_global_thread_num(ptr) local_unnamed_addr #2

; Function Attrs: nounwind
declare !callback !10 void @__kmpc_fork_call(ptr, i32, ptr, ...) local_unnamed_addr #2

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #4

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #5

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #5

attributes #0 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #1 = { mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #2 = { nounwind }
attributes #3 = { norecurse nounwind }
attributes #4 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #5 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i32 7, !"openmp", i32 11}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{!5, !5, i64 0}
!5 = !{!"any data access", !6, i64 0}
!6 = !{!"any access", !7, i64 0}
!7 = !{!"Flang Type TBAA Root"}
!8 = !{!9, !9, i64 0}
!9 = !{!"descriptor member", !6, i64 0}
!10 = !{!11}
!11 = !{i64 2, i64 -1, i64 -1, i1 true}
*** IR Dump After RecomputeGlobalsAAPass on [module] ***
; ModuleID = 'FIRModule'
source_filename = "FIRModule"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.ident_t = type { i32, i32, i32, i32, ptr }

@_QQcl.28612C69372C612C6531332E36653229 = internal constant [16 x i8] c"(a,i7,a,e13.6e2)"
@_QQcl.21557d42704c5c1f18a68415065290ee = internal constant [50 x i8] c"/g/g92/rydahl1/flangtests/src/parallel_region.f90\00"
@_QQcl.54686520726573756C74206F6620286172722831292B61727228 = internal constant [26 x i8] c"The result of (arr(1)+arr("
@_QQcl.2920697320 = internal constant [5 x i8] c") is "
@_QQEnvironmentDefaults = local_unnamed_addr constant ptr null
@0 = private unnamed_addr constant [23 x i8] c";unknown;unknown;0;0;;\00", align 1
@1 = private unnamed_addr constant %struct.ident_t { i32 0, i32 2, i32 0, i32 22, ptr @0 }, align 8

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite)
declare noalias noundef ptr @malloc(i64 noundef) local_unnamed_addr #0

; Function Attrs: mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite)
declare void @free(ptr allocptr nocapture noundef) local_unnamed_addr #1

define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}

; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}

; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}

declare ptr @_FortranAioBeginExternalFormattedOutput(ptr, i64, ptr, i32, ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputAscii(ptr, ptr, i64) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputInteger32(ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputReal64(ptr, double) local_unnamed_addr

declare i32 @_FortranAioEndIoStatement(ptr) local_unnamed_addr

; Function Attrs: nounwind
declare i32 @omp_get_thread_num() local_unnamed_addr #2

; Function Attrs: nounwind
declare i32 @omp_get_num_threads() local_unnamed_addr #2

; Function Attrs: nounwind
declare i32 @__kmpc_global_thread_num(ptr) local_unnamed_addr #2

; Function Attrs: nounwind
declare !callback !10 void @__kmpc_fork_call(ptr, i32, ptr, ...) local_unnamed_addr #2

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #4

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #5

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #5

attributes #0 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #1 = { mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #2 = { nounwind }
attributes #3 = { norecurse nounwind }
attributes #4 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #5 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i32 7, !"openmp", i32 11}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{!5, !5, i64 0}
!5 = !{!"any data access", !6, i64 0}
!6 = !{!"any access", !7, i64 0}
!7 = !{!"Flang Type TBAA Root"}
!8 = !{!9, !9, i64 0}
!9 = !{!"descriptor member", !6, i64 0}
!10 = !{!11}
!11 = !{i64 2, i64 -1, i64 -1, i1 true}
*** IR Dump After Float2IntPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After LowerConstantIntrinsicsPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After ControlHeightReductionPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After LoopSimplifyPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After LCSSAPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After LoopDistributePass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After InjectTLIMappings on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After LoopVectorizePass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After LoopLoadEliminationPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After InstCombinePass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After SimplifyCFGPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After VectorCombinePass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After InstCombinePass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After LoopUnrollPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After WarnMissedTransformationsPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After SROAPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After InstCombinePass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After LoopSimplifyPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After LCSSAPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After AlignmentFromAssumptionsPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After LoopSinkPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After InstSimplifyPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After DivRemPairsPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After TailCallElimPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After SimplifyCFGPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After Float2IntPass on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After LowerConstantIntrinsicsPass on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After ControlHeightReductionPass on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After LoopSimplifyPass on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After LCSSAPass on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After LoopDistributePass on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After InjectTLIMappings on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After LoopVectorizePass on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After LoopLoadEliminationPass on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After InstCombinePass on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After SimplifyCFGPass on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After VectorCombinePass on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After InstCombinePass on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After LoopUnrollPass on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After WarnMissedTransformationsPass on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After SROAPass on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After InstCombinePass on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After LoopSimplifyPass on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After LCSSAPass on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After AlignmentFromAssumptionsPass on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After LoopSinkPass on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After InstSimplifyPass on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After DivRemPairsPass on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After TailCallElimPass on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After SimplifyCFGPass on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After Float2IntPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}
*** IR Dump After LowerConstantIntrinsicsPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}
*** IR Dump After ControlHeightReductionPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}
*** IR Dump After LoopSimplifyPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After LCSSAPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After LoopRotatePass on omp.par.region6 ***

; Preheader:
omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

; Loop:
omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit

; Exit blocks
omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7
*** IR Dump After LoopDeletionPass on omp.par.region6 ***

; Preheader:
omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

; Loop:
omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit

; Exit blocks
omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7
*** IR Dump After LoopDistributePass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After InjectTLIMappings on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After LoopVectorizePass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After LoopLoadEliminationPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After InstCombinePass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After SimplifyCFGPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}
*** IR Dump After VectorCombinePass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}
*** IR Dump After InstCombinePass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}
*** IR Dump After LoopUnrollPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After WarnMissedTransformationsPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After SROAPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After InstCombinePass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After LoopSimplifyPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After LCSSAPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After LICMPass on omp.par.region6 ***

; Preheader:
omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

; Loop:
omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit

; Exit blocks
omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7
*** IR Dump After AlignmentFromAssumptionsPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After LoopSinkPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After InstSimplifyPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After DivRemPairsPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After TailCallElimPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7.loopexit:                         ; preds = %omp.par.region6
  br label %omp.par.region7

omp.par.region7:                                  ; preds = %omp.par.region7.loopexit, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7.loopexit
}
*** IR Dump After SimplifyCFGPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}
*** IR Dump After GlobalDCEPass on [module] ***
; ModuleID = 'FIRModule'
source_filename = "FIRModule"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.ident_t = type { i32, i32, i32, i32, ptr }

@_QQcl.28612C69372C612C6531332E36653229 = internal constant [16 x i8] c"(a,i7,a,e13.6e2)"
@_QQcl.21557d42704c5c1f18a68415065290ee = internal constant [50 x i8] c"/g/g92/rydahl1/flangtests/src/parallel_region.f90\00"
@_QQcl.54686520726573756C74206F6620286172722831292B61727228 = internal constant [26 x i8] c"The result of (arr(1)+arr("
@_QQcl.2920697320 = internal constant [5 x i8] c") is "
@_QQEnvironmentDefaults = local_unnamed_addr constant ptr null
@0 = private unnamed_addr constant [23 x i8] c";unknown;unknown;0;0;;\00", align 1
@1 = private unnamed_addr constant %struct.ident_t { i32 0, i32 2, i32 0, i32 22, ptr @0 }, align 8

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite)
declare noalias noundef ptr @malloc(i64 noundef) local_unnamed_addr #0

; Function Attrs: mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite)
declare void @free(ptr allocptr nocapture noundef) local_unnamed_addr #1

define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}

; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}

; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}

declare ptr @_FortranAioBeginExternalFormattedOutput(ptr, i64, ptr, i32, ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputAscii(ptr, ptr, i64) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputInteger32(ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputReal64(ptr, double) local_unnamed_addr

declare i32 @_FortranAioEndIoStatement(ptr) local_unnamed_addr

; Function Attrs: nounwind
declare i32 @omp_get_thread_num() local_unnamed_addr #2

; Function Attrs: nounwind
declare i32 @omp_get_num_threads() local_unnamed_addr #2

; Function Attrs: nounwind
declare i32 @__kmpc_global_thread_num(ptr) local_unnamed_addr #2

; Function Attrs: nounwind
declare !callback !10 void @__kmpc_fork_call(ptr, i32, ptr, ...) local_unnamed_addr #2

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #4

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #5

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #5

attributes #0 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #1 = { mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #2 = { nounwind }
attributes #3 = { norecurse nounwind }
attributes #4 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #5 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i32 7, !"openmp", i32 11}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{!5, !5, i64 0}
!5 = !{!"any data access", !6, i64 0}
!6 = !{!"any access", !7, i64 0}
!7 = !{!"Flang Type TBAA Root"}
!8 = !{!9, !9, i64 0}
!9 = !{!"descriptor member", !6, i64 0}
!10 = !{!11}
!11 = !{i64 2, i64 -1, i64 -1, i1 true}
*** IR Dump After ConstantMergePass on [module] ***
; ModuleID = 'FIRModule'
source_filename = "FIRModule"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.ident_t = type { i32, i32, i32, i32, ptr }

@_QQcl.28612C69372C612C6531332E36653229 = internal constant [16 x i8] c"(a,i7,a,e13.6e2)"
@_QQcl.21557d42704c5c1f18a68415065290ee = internal constant [50 x i8] c"/g/g92/rydahl1/flangtests/src/parallel_region.f90\00"
@_QQcl.54686520726573756C74206F6620286172722831292B61727228 = internal constant [26 x i8] c"The result of (arr(1)+arr("
@_QQcl.2920697320 = internal constant [5 x i8] c") is "
@_QQEnvironmentDefaults = local_unnamed_addr constant ptr null
@0 = private unnamed_addr constant [23 x i8] c";unknown;unknown;0;0;;\00", align 1
@1 = private unnamed_addr constant %struct.ident_t { i32 0, i32 2, i32 0, i32 22, ptr @0 }, align 8

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite)
declare noalias noundef ptr @malloc(i64 noundef) local_unnamed_addr #0

; Function Attrs: mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite)
declare void @free(ptr allocptr nocapture noundef) local_unnamed_addr #1

define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}

; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}

; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}

declare ptr @_FortranAioBeginExternalFormattedOutput(ptr, i64, ptr, i32, ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputAscii(ptr, ptr, i64) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputInteger32(ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputReal64(ptr, double) local_unnamed_addr

declare i32 @_FortranAioEndIoStatement(ptr) local_unnamed_addr

; Function Attrs: nounwind
declare i32 @omp_get_thread_num() local_unnamed_addr #2

; Function Attrs: nounwind
declare i32 @omp_get_num_threads() local_unnamed_addr #2

; Function Attrs: nounwind
declare i32 @__kmpc_global_thread_num(ptr) local_unnamed_addr #2

; Function Attrs: nounwind
declare !callback !10 void @__kmpc_fork_call(ptr, i32, ptr, ...) local_unnamed_addr #2

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #4

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #5

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #5

attributes #0 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #1 = { mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #2 = { nounwind }
attributes #3 = { norecurse nounwind }
attributes #4 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #5 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i32 7, !"openmp", i32 11}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{!5, !5, i64 0}
!5 = !{!"any data access", !6, i64 0}
!6 = !{!"any access", !7, i64 0}
!7 = !{!"Flang Type TBAA Root"}
!8 = !{!9, !9, i64 0}
!9 = !{!"descriptor member", !6, i64 0}
!10 = !{!11}
!11 = !{i64 2, i64 -1, i64 -1, i1 true}
*** IR Dump After CGProfilePass on [module] ***
; ModuleID = 'FIRModule'
source_filename = "FIRModule"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.ident_t = type { i32, i32, i32, i32, ptr }

@_QQcl.28612C69372C612C6531332E36653229 = internal constant [16 x i8] c"(a,i7,a,e13.6e2)"
@_QQcl.21557d42704c5c1f18a68415065290ee = internal constant [50 x i8] c"/g/g92/rydahl1/flangtests/src/parallel_region.f90\00"
@_QQcl.54686520726573756C74206F6620286172722831292B61727228 = internal constant [26 x i8] c"The result of (arr(1)+arr("
@_QQcl.2920697320 = internal constant [5 x i8] c") is "
@_QQEnvironmentDefaults = local_unnamed_addr constant ptr null
@0 = private unnamed_addr constant [23 x i8] c";unknown;unknown;0;0;;\00", align 1
@1 = private unnamed_addr constant %struct.ident_t { i32 0, i32 2, i32 0, i32 22, ptr @0 }, align 8

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite)
declare noalias noundef ptr @malloc(i64 noundef) local_unnamed_addr #0

; Function Attrs: mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite)
declare void @free(ptr allocptr nocapture noundef) local_unnamed_addr #1

define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}

; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}

; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}

declare ptr @_FortranAioBeginExternalFormattedOutput(ptr, i64, ptr, i32, ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputAscii(ptr, ptr, i64) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputInteger32(ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputReal64(ptr, double) local_unnamed_addr

declare i32 @_FortranAioEndIoStatement(ptr) local_unnamed_addr

; Function Attrs: nounwind
declare i32 @omp_get_thread_num() local_unnamed_addr #2

; Function Attrs: nounwind
declare i32 @omp_get_num_threads() local_unnamed_addr #2

; Function Attrs: nounwind
declare i32 @__kmpc_global_thread_num(ptr) local_unnamed_addr #2

; Function Attrs: nounwind
declare !callback !10 void @__kmpc_fork_call(ptr, i32, ptr, ...) local_unnamed_addr #2

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #4

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #5

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #5

attributes #0 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #1 = { mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #2 = { nounwind }
attributes #3 = { norecurse nounwind }
attributes #4 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #5 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i32 7, !"openmp", i32 11}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{!5, !5, i64 0}
!5 = !{!"any data access", !6, i64 0}
!6 = !{!"any access", !7, i64 0}
!7 = !{!"Flang Type TBAA Root"}
!8 = !{!9, !9, i64 0}
!9 = !{!"descriptor member", !6, i64 0}
!10 = !{!11}
!11 = !{i64 2, i64 -1, i64 -1, i1 true}
*** IR Dump After RelLookupTableConverterPass on [module] ***
; ModuleID = 'FIRModule'
source_filename = "FIRModule"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.ident_t = type { i32, i32, i32, i32, ptr }

@_QQcl.28612C69372C612C6531332E36653229 = internal constant [16 x i8] c"(a,i7,a,e13.6e2)"
@_QQcl.21557d42704c5c1f18a68415065290ee = internal constant [50 x i8] c"/g/g92/rydahl1/flangtests/src/parallel_region.f90\00"
@_QQcl.54686520726573756C74206F6620286172722831292B61727228 = internal constant [26 x i8] c"The result of (arr(1)+arr("
@_QQcl.2920697320 = internal constant [5 x i8] c") is "
@_QQEnvironmentDefaults = local_unnamed_addr constant ptr null
@0 = private unnamed_addr constant [23 x i8] c";unknown;unknown;0;0;;\00", align 1
@1 = private unnamed_addr constant %struct.ident_t { i32 0, i32 2, i32 0, i32 22, ptr @0 }, align 8

; Function Attrs: mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite)
declare noalias noundef ptr @malloc(i64 noundef) local_unnamed_addr #0

; Function Attrs: mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite)
declare void @free(ptr allocptr nocapture noundef) local_unnamed_addr #1

define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}

; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}

; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}

declare ptr @_FortranAioBeginExternalFormattedOutput(ptr, i64, ptr, i32, ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputAscii(ptr, ptr, i64) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputInteger32(ptr, i32) local_unnamed_addr

declare zeroext i1 @_FortranAioOutputReal64(ptr, double) local_unnamed_addr

declare i32 @_FortranAioEndIoStatement(ptr) local_unnamed_addr

; Function Attrs: nounwind
declare i32 @omp_get_thread_num() local_unnamed_addr #2

; Function Attrs: nounwind
declare i32 @omp_get_num_threads() local_unnamed_addr #2

; Function Attrs: nounwind
declare i32 @__kmpc_global_thread_num(ptr) local_unnamed_addr #2

; Function Attrs: nounwind
declare !callback !10 void @__kmpc_fork_call(ptr, i32, ptr, ...) local_unnamed_addr #2

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i32 @llvm.smax.i32(i32, i32) #4

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #5

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #5

attributes #0 = { mustprogress nofree nounwind willreturn allockind("alloc,uninitialized") allocsize(0) memory(inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #1 = { mustprogress nounwind willreturn allockind("free") memory(argmem: readwrite, inaccessiblemem: readwrite) "alloc-family"="malloc" }
attributes #2 = { nounwind }
attributes #3 = { norecurse nounwind }
attributes #4 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #5 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = !{i32 7, !"openmp", i32 11}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{!5, !5, i64 0}
!5 = !{!"any data access", !6, i64 0}
!6 = !{!"any access", !7, i64 0}
!7 = !{!"Flang Type TBAA Root"}
!8 = !{!9, !9, i64 0}
!9 = !{!"descriptor member", !6, i64 0}
!10 = !{!11}
!11 = !{i64 2, i64 -1, i64 -1, i1 true}
*** IR Dump After AnnotationRemarksPass on _QQmain ***
define void @_QQmain() local_unnamed_addr {
  %structArg.i = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %1 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca double, align 8
  %5 = alloca i32, align 4
  store i32 1048576, ptr %5, align 4, !tbaa !4
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %4)
  %.fca.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 1
  %.fca.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 2
  %.fca.3.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 3
  %.fca.4.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 4
  %.fca.5.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 5
  %.fca.6.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 6
  %.fca.7.0.0.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep.i = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %3, i64 0, i32 7, i64 0, i64 2
  %6 = tail call dereferenceable_or_null(8388608) ptr @malloc(i64 8388608)
  store ptr %6, ptr %3, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep.i, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep.i, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep.i, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep.i, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep.i, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep.i, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  store i64 1048576, ptr %.fca.7.0.1.gep.i, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep.i, align 8, !tbaa !8
  %omp_global_thread_num.i = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %5, ptr %structArg.i, align 8
  %gep_8.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 1
  store ptr %3, ptr %gep_8.i, align 8
  %gep_9.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 2
  store ptr %2, ptr %gep_9.i, align 8
  %gep_10.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 3
  store ptr %1, ptr %gep_10.i, align 8
  %gep_11.i = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg.i, i64 0, i32 4
  store ptr %4, ptr %gep_11.i, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg.i)
  %.fca.0.load.i = load ptr, ptr %3, align 8, !tbaa !8
  %.fca.7.0.0.load.i = load i64, ptr %.fca.7.0.0.gep.i, align 8, !tbaa !8
  %7 = sub i64 1, %.fca.7.0.0.load.i
  %8 = getelementptr double, ptr %.fca.0.load.i, i64 %7
  %9 = load double, ptr %8, align 8, !tbaa !4
  %10 = load i32, ptr %5, align 4, !tbaa !4
  %11 = sext i32 %10 to i64
  %12 = sub i64 %11, %.fca.7.0.0.load.i
  %13 = getelementptr double, ptr %.fca.0.load.i, i64 %12
  %14 = load double, ptr %13, align 8, !tbaa !4
  %15 = fadd contract double %9, %14
  call void @free(ptr %.fca.0.load.i)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %structArg.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %1)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %2)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %3)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %4)
  %16 = call ptr @_FortranAioBeginExternalFormattedOutput(ptr nonnull @_QQcl.28612C69372C612C6531332E36653229, i64 16, ptr null, i32 -1, ptr nonnull @_QQcl.21557d42704c5c1f18a68415065290ee, i32 10)
  %17 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.54686520726573756C74206F6620286172722831292B61727228, i64 26)
  %18 = load i32, ptr %5, align 4, !tbaa !4
  %19 = call i1 @_FortranAioOutputInteger32(ptr %16, i32 %18)
  %20 = call i1 @_FortranAioOutputAscii(ptr %16, ptr nonnull @_QQcl.2920697320, i64 5)
  %21 = call i1 @_FortranAioOutputReal64(ptr %16, double %15)
  %22 = call i32 @_FortranAioEndIoStatement(ptr %16)
  ret void
}
*** IR Dump After AnnotationRemarksPass on _QFPomp_subroutine ***
; Function Attrs: nounwind
define void @_QFPomp_subroutine(ptr %0, ptr nocapture writeonly %1) local_unnamed_addr #2 {
entry:
  %structArg = alloca { ptr, ptr, ptr, ptr, ptr }, align 8
  %2 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %3 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %4 = alloca { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, align 8
  %.fca.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 1
  %.fca.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 2
  %.fca.3.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 3
  %.fca.4.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 4
  %.fca.5.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 5
  %.fca.6.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 6
  %.fca.7.0.0.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 0
  %.fca.7.0.1.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 1
  %.fca.7.0.2.gep = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %4, i64 0, i32 7, i64 0, i64 2
  %5 = alloca double, align 8
  %6 = load i32, ptr %0, align 4, !tbaa !4
  %7 = tail call i32 @llvm.smax.i32(i32 %6, i32 0)
  %8 = zext i32 %7 to i64
  %9 = shl nuw nsw i64 %8, 3
  %10 = tail call ptr @malloc(i64 %9)
  store ptr %10, ptr %4, align 8, !tbaa !8
  store i64 8, ptr %.fca.1.gep, align 8, !tbaa !8
  store i32 20180515, ptr %.fca.2.gep, align 8, !tbaa !8
  store i8 1, ptr %.fca.3.gep, align 4, !tbaa !8
  store i8 28, ptr %.fca.4.gep, align 1, !tbaa !8
  store i8 2, ptr %.fca.5.gep, align 2, !tbaa !8
  store i8 0, ptr %.fca.6.gep, align 1, !tbaa !8
  store i64 1, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  store i64 %8, ptr %.fca.7.0.1.gep, align 8, !tbaa !8
  store i64 8, ptr %.fca.7.0.2.gep, align 8, !tbaa !8
  %omp_global_thread_num = tail call i32 @__kmpc_global_thread_num(ptr nonnull @1)
  store ptr %0, ptr %structArg, align 8
  %gep_8 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 1
  store ptr %4, ptr %gep_8, align 8
  %gep_9 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 2
  store ptr %3, ptr %gep_9, align 8
  %gep_10 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 3
  store ptr %2, ptr %gep_10, align 8
  %gep_11 = getelementptr inbounds { ptr, ptr, ptr, ptr, ptr }, ptr %structArg, i64 0, i32 4
  store ptr %5, ptr %gep_11, align 8
  call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr nonnull @1, i32 1, ptr nonnull @_QFPomp_subroutine..omp_par, ptr nonnull %structArg)
  %.fca.0.load = load ptr, ptr %4, align 8, !tbaa !8
  %.fca.7.0.0.load = load i64, ptr %.fca.7.0.0.gep, align 8, !tbaa !8
  %11 = sub i64 1, %.fca.7.0.0.load
  %12 = getelementptr double, ptr %.fca.0.load, i64 %11
  %13 = load double, ptr %12, align 8, !tbaa !4
  %14 = load i32, ptr %0, align 4, !tbaa !4
  %15 = sext i32 %14 to i64
  %16 = sub i64 %15, %.fca.7.0.0.load
  %17 = getelementptr double, ptr %.fca.0.load, i64 %16
  %18 = load double, ptr %17, align 8, !tbaa !4
  %19 = fadd contract double %13, %18
  store double %19, ptr %1, align 8, !tbaa !4
  call void @free(ptr %.fca.0.load)
  ret void
}
*** IR Dump After AnnotationRemarksPass on _QFPomp_subroutine..omp_par ***
; Function Attrs: norecurse nounwind
define internal void @_QFPomp_subroutine..omp_par(ptr noalias nocapture readnone %tid.addr, ptr noalias nocapture readnone %zero.addr, ptr nocapture readonly %0) #3 {
omp.par.entry:
  %loadgep_ = load ptr, ptr %0, align 8
  %gep_1 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 1
  %loadgep_2 = load ptr, ptr %gep_1, align 8
  %gep_3 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 2
  %loadgep_4 = load ptr, ptr %gep_3, align 8
  %gep_5 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 3
  %loadgep_6 = load ptr, ptr %gep_5, align 8
  %gep_7 = getelementptr { ptr, ptr, ptr, ptr, ptr }, ptr %0, i64 0, i32 4
  %loadgep_8 = load ptr, ptr %gep_7, align 8
  %1 = tail call i32 @omp_get_thread_num()
  %2 = tail call i32 @omp_get_num_threads()
  %3 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %4 = sdiv i32 %3, %2
  %5 = mul i32 %4, %1
  %6 = add i32 %5, 1
  %7 = add i32 %2, -1
  %8 = icmp eq i32 %1, %7
  %9 = add i32 %6, %4
  %.0 = select i1 %8, i32 %3, i32 %9
  %10 = sext i32 %6 to i64
  %11 = sext i32 %.0 to i64
  %reass.sub = sub nsw i64 %11, %10
  %12 = icmp sgt i64 %reass.sub, -1
  br i1 %12, label %omp.par.region6.lr.ph, label %omp.par.region7

omp.par.region6.lr.ph:                            ; preds = %omp.par.entry
  %13 = add nuw nsw i64 %reass.sub, 1
  %.elt21 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 1
  %.elt23 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 2
  %.elt25 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 3
  %.elt27 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 4
  %.elt29 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 5
  %.elt31 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 6
  %.elt33 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7
  %.unpack34.unpack.elt36 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 1
  %.unpack34.unpack.elt38 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_2, i64 0, i32 7, i64 0, i64 2
  %loadgep_4.repack41 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 1
  %loadgep_4.repack43 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 2
  %loadgep_4.repack45 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 3
  %loadgep_4.repack47 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 4
  %loadgep_4.repack49 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 5
  %loadgep_4.repack51 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 6
  %loadgep_4.repack53 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7
  %loadgep_4.repack53.repack55 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 1
  %loadgep_4.repack53.repack57 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_4, i64 0, i32 7, i64 0, i64 2
  %loadgep_6.repack80 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 1
  %loadgep_6.repack82 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 2
  %loadgep_6.repack84 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 3
  %loadgep_6.repack86 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 4
  %loadgep_6.repack88 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 5
  %loadgep_6.repack90 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 6
  %loadgep_6.repack92 = getelementptr { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7
  %loadgep_6.repack92.repack94 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 1
  %loadgep_6.repack92.repack96 = getelementptr inbounds { ptr, i64, i32, i8, i8, i8, i8, [1 x [3 x i64]] }, ptr %loadgep_6, i64 0, i32 7, i64 0, i64 2
  br label %omp.par.region6

omp.par.region7:                                  ; preds = %omp.par.region6, %omp.par.entry
  ret void

omp.par.region6:                                  ; preds = %omp.par.region6.lr.ph, %omp.par.region6
  %14 = phi i64 [ %13, %omp.par.region6.lr.ph ], [ %27, %omp.par.region6 ]
  %15 = phi i32 [ %6, %omp.par.region6.lr.ph ], [ %26, %omp.par.region6 ]
  %16 = load i32, ptr %loadgep_, align 4, !tbaa !4
  %17 = sitofp i32 %16 to float
  %18 = fdiv contract float 1.000000e+00, %17
  %19 = fpext float %18 to double
  %.unpack = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack22 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack24 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack26 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack28 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack30 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack32 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack34.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack34.unpack.unpack37 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack34.unpack.unpack39 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack, ptr %loadgep_4, align 8, !tbaa !8
  store i64 %.unpack22, ptr %loadgep_4.repack41, align 8, !tbaa !8
  store i32 %.unpack24, ptr %loadgep_4.repack43, align 8, !tbaa !8
  store i8 %.unpack26, ptr %loadgep_4.repack45, align 4, !tbaa !8
  store i8 %.unpack28, ptr %loadgep_4.repack47, align 1, !tbaa !8
  store i8 %.unpack30, ptr %loadgep_4.repack49, align 2, !tbaa !8
  store i8 %.unpack32, ptr %loadgep_4.repack51, align 1, !tbaa !8
  store i64 %.unpack34.unpack.unpack, ptr %loadgep_4.repack53, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack37, ptr %loadgep_4.repack53.repack55, align 8, !tbaa !8
  store i64 %.unpack34.unpack.unpack39, ptr %loadgep_4.repack53.repack57, align 8, !tbaa !8
  %20 = sext i32 %15 to i64
  %21 = sub i64 %20, %.unpack34.unpack.unpack
  %22 = getelementptr double, ptr %.unpack, i64 %21
  store double %19, ptr %22, align 8, !tbaa !4
  %.unpack59 = load ptr, ptr %loadgep_2, align 8, !tbaa !8
  %.unpack61 = load i64, ptr %.elt21, align 8, !tbaa !8
  %.unpack63 = load i32, ptr %.elt23, align 8, !tbaa !8
  %.unpack65 = load i8, ptr %.elt25, align 4, !tbaa !8
  %.unpack67 = load i8, ptr %.elt27, align 1, !tbaa !8
  %.unpack69 = load i8, ptr %.elt29, align 2, !tbaa !8
  %.unpack71 = load i8, ptr %.elt31, align 1, !tbaa !8
  %.unpack73.unpack.unpack = load i64, ptr %.elt33, align 8, !tbaa !8
  %.unpack73.unpack.unpack76 = load i64, ptr %.unpack34.unpack.elt36, align 8, !tbaa !8
  %.unpack73.unpack.unpack78 = load i64, ptr %.unpack34.unpack.elt38, align 8, !tbaa !8
  store ptr %.unpack59, ptr %loadgep_6, align 8, !tbaa !8
  store i64 %.unpack61, ptr %loadgep_6.repack80, align 8, !tbaa !8
  store i32 %.unpack63, ptr %loadgep_6.repack82, align 8, !tbaa !8
  store i8 %.unpack65, ptr %loadgep_6.repack84, align 4, !tbaa !8
  store i8 %.unpack67, ptr %loadgep_6.repack86, align 1, !tbaa !8
  store i8 %.unpack69, ptr %loadgep_6.repack88, align 2, !tbaa !8
  store i8 %.unpack71, ptr %loadgep_6.repack90, align 1, !tbaa !8
  store i64 %.unpack73.unpack.unpack, ptr %loadgep_6.repack92, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack76, ptr %loadgep_6.repack92.repack94, align 8, !tbaa !8
  store i64 %.unpack73.unpack.unpack78, ptr %loadgep_6.repack92.repack96, align 8, !tbaa !8
  %23 = sub i64 %20, %.unpack73.unpack.unpack
  %24 = getelementptr double, ptr %.unpack59, i64 %23
  %25 = load double, ptr %24, align 8, !tbaa !4
  store double %25, ptr %loadgep_8, align 8, !tbaa !4
  %26 = add i32 %15, 1
  %27 = add nsw i64 %14, -1
  %28 = icmp ugt i64 %14, 1
  br i1 %28, label %omp.par.region6, label %omp.par.region7
}
